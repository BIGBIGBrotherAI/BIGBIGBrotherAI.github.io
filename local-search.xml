<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>机器视觉测量与建模</title>
    <link href="/2024/01/07/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E6%B5%8B%E9%87%8F%E4%B8%8E%E5%BB%BA%E6%A8%A1/"/>
    <url>/2024/01/07/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E6%B5%8B%E9%87%8F%E4%B8%8E%E5%BB%BA%E6%A8%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="机器视觉测量与建模">机器视觉测量与建模</h1><h2 id="机器视觉的发展">1.机器视觉的发展</h2><h3 id="三维测量与建模的应用举例">1.1 三维测量与建模的应用举例</h3><h3 id="视觉处理种的挑战问题">1.2 视觉处理种的挑战问题</h3><h2 id="图像处理的基础">2.图像处理的基础</h2><h3 id="图像的感知与获取">2.1 图像的感知与获取</h3><h3 id="坐标转换基础">2.2 坐标转换基础</h3><h3 id="透视投影的相机模型">2.3 透视投影的相机模型</h3><h3 id="射影几何基础">2.4 射影几何基础</h3><h2 id="特征提取与匹配">3.特征提取与匹配</h2><h3 id="相机标定的基本概念">3.1 相机标定的基本概念</h3><p>相机标定有多种含义，包括辐射定标、颜色校正、几何校准、噪声校准、透镜的像差标准等。本文涉及的主要是几何标定。</p><h3 id="直接线性变换法标定">3.2 直接线性变换法标定</h3><h3 id="棋盘格相机标定方法">3.3 棋盘格相机标定方法</h3><h3 id="基于灭点平行线消失点相机标定方法">3.4基于灭点(平行线消失点)相机标定方法</h3><h4 id="基于灭点平行线消失点相机标定方法概述">3.4.1基于灭点(平行线消失点)相机标定方法概述</h4><ul><li>灭点的定义</li></ul><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20240107022139498.png"alt="image-20240107022139498" /><figcaption aria-hidden="true">image-20240107022139498</figcaption></figure><ul><li>灭点有三种</li></ul><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20240107022213078.png"alt="image-20240107022213078" /><figcaption aria-hidden="true">image-20240107022213078</figcaption></figure><ul><li>通过灭点的正交方向确定<strong>绝对圆锥曲线</strong> <spanclass="math inline">\(IACω\)</span>,标内参</li></ul><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20240107022624283.png"alt="image-20240107022624283" /><figcaption aria-hidden="true">image-20240107022624283</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20240107022921135.png"alt="image-20240107022921135" /><figcaption aria-hidden="true">image-20240107022921135</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20240107023451654.png"alt="image-20240107023451654" /><figcaption aria-hidden="true">image-20240107023451654</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20240107041321631.png"alt="image-20240107041321631" /><figcaption aria-hidden="true">image-20240107041321631</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20240107041455296.png"alt="image-20240107041455296" /><figcaption aria-hidden="true">image-20240107041455296</figcaption></figure><h4 id="基于代数和几何方法的单张图像线性标定分析和实现">3.4.2基于代数和几何方法的单张图像线性标定分析和实现</h4><p>已知单张具有3条正交消失线的场景图像（或者至少有2条正交线，此时假设主点为图像中心），则可直接估算相机内参，另外如果已知场景图像中某些物体的实际尺寸或者坐标，则还可估计相机外参旋转矩阵<span class="math inline">\(R\)</span> ，相机外参平移向量 <spanclass="math inline">\(T\)</span> 。</p><p>在基于3个消失点坐标计算已知的情况下，可以分别通过计算相机内参 <spanclass="math inline">\(K\)</span> 、外参 <spanclass="math inline">\(R\)</span> 、 <spanclass="math inline">\(T\)</span> 这三个步骤逐渐恢复相机位姿。其中 <spanclass="math inline">\(K\)</span> 需具有焦距 <spanclass="math inline">\(f\)</span> ，主点 <spanclass="math inline">\(\left(u_0 ,v_0 \right)\)</span>三个独立未知变量。</p><h5 id="计算相机内参k">计算相机内参K</h5><ul><li>代数方法：</li></ul><p>单张图像场景中，三个正交的消失线方向向量 <spanclass="math inline">\(e_1 =\left\lbrack \begin{array}{c} 1\\ 0\\ 0\end{array}\right\rbrack ,e_2 =\left\lbrack \begin{array}{c} 0\\ 1\\ 0\end{array}\right\rbrack ,e_3 =\left\lbrack \begin{array}{c} 0\\ 0\\ 1\end{array}\right\rbrack\)</span> ， 满足投影公式</p><p><span class="math inline">\(\lambda_i \left\lbrack \begin{array}{c}x\\ 1 \end{array}\right\rbrack =K*\left\lbrack R,t\right\rbrack*\left\lbrack \begin{array}{c} e_i \\ 0\end{array}\right\rbrack\)</span> , (1)</p><p>注意位于无限远处的消失点齐次坐标是 <spanclass="math inline">\(\left\lbrack \begin{array}{c} e_i \\ 0\end{array}\right\rbrack\)</span> .整理上式，得：</p><p><span class="math inline">\(e_i =\lambda_i R^T K^{-1} \left\lbrack\begin{array}{c} x\\ 1 \end{array}\right\rbrack\)</span> ， (2)</p><p>又由正交性约束,有 <span class="math inline">\({e_i }^T e_j=0\)</span> ,得：</p><p>​ (3)</p><p>K的求解通过(3)求解，实现为calIntrinsicFrom3VanishingPts.m函数。</p><ul><li><p>几何方法：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/triPlot2.jpg"alt="triPlot2" /><figcaption aria-hidden="true">triPlot2</figcaption></figure></li></ul><p>四面体PABC为直角四面体（顶点P为互相垂直的三条棱线经过），底面三角形ABC为像平面，A,B,C为图像平面的三个消失点坐标，其中z值为<span class="math inline">\(f\)</span>，P点为相机光心，P点到底面ABC的距离为焦距 <spanclass="math inline">\(f\)</span>，垂足为底面三角形ABC的垂心，垂心坐标为相机主点 <spanclass="math inline">\(O_c \left(u_0 ,v_0 \right)\)</span> .</p><h5 id="计算外参旋转矩阵r">计算外参旋转矩阵R</h5><ul><li>代数方法：</li></ul><p>由</p><p><span class="math inline">\(\lambda_i {\left\lbrack \begin{array}{c}x_1 \\ x_2 \\ 1 \end{array}\right\rbrack }_i ={K*R*e}_i\)</span> ,(4)</p><p>两边左乘 <span class="math inline">\(K^{-1}\)</span> ，</p><p><span class="math inline">\(\lambda_i K^{-1} {\left\lbrack\begin{array}{c} x_1 \\ x_2 \\ 1 \end{array}\right\rbrack }_i={R*e}_i\)</span> , (5)</p><p>注意： <span class="math inline">\({R*e}_1 =\left\lbrack r_{1,} r_2,r_3 \right\rbrack \left\lbrack \begin{array}{c} 1\\ 0\\ 0\end{array}\right\rbrack =r_1\)</span> ,得：</p><p><span class="math inline">\({r_i =\lambda }_i K^{-1} {\left\lbrack\begin{array}{c} x_1 \\ x_2 \\ 1 \end{array}\right\rbrack }_i\)</span>，(其中 <span class="math inline">\(\lambda_i\)</span> 可以通过 <spanclass="math inline">\(\left\|r_i \right\|=1\)</span> 约束求解，这里<span class="math inline">\(r_i\)</span> 为外参旋转矩阵的第 <spanclass="math inline">\(i\)</span> 列)</p><ul><li>几何方法：</li></ul><p><span class="math inline">\(r_i =\frac{\vec{P{\mathrm{V}}_i }}{\left\|\vec{P{\mathrm{V}}_i } \right\|}\)</span> ，(其中 <spanclass="math inline">\({\mathrm{V}}_i\)</span> 为消失点， <spanclass="math inline">\(\vec{P{\mathrm{V}}_i }\)</span>为相机光心到像平面消失点的三维方向矢量也即空间消失线的三维方向矢量！)</p><h5 id="计算外参平移向量t">计算外参平移向量T</h5><ul><li>代数方法：</li></ul><p>这里边计算边分析推导：</p><p><span class="math display">\[ \lambda_i {\left\lbrack\begin{array}{c} x\\ 1 \end{array}\right\rbrack } =K*\left\lbrackR,t\right\rbrack *{\left\lbrack \begin{array}{c} X\\ 1\end{array}\right\rbrack }_i \]</span></p><p>展开，写成标量形式，即 <span class="math inline">\(\lambda_i\left\lbrack \begin{array}{c} x_1 \\ x_2 \\ 1 \end{array}\right\rbrack=\left\lbrack \begin{array}{ccc} f &amp; 0 &amp; u_0 \\ 0 &amp; f &amp;v_0 \\ 0 &amp; 0 &amp; 1 \end{array}\right\rbrack *\left\lbrack\begin{array}{cccc} R_{11}  &amp; R_{12}  &amp; R_{13}  &amp; t_1 \\R_{21}  &amp; R_{22}  &amp; R_{23}  &amp; t_2 \\ R_{31}  &amp;R_{32}  &amp; R_{33}  &amp; t_3  \end{array}\right\rbrack *\left\lbrack\begin{array}{c} X_1 \\ X_2 \\ X_3 \\ 1\end{array}\right\rbrack\)</span></p><p>其中内参矩阵 <span class="math inline">\(K\)</span> ： <spanclass="math inline">\(K=\displaystyle \left(\begin{array}{ccc} f &amp; 0&amp; u_0 \\ 0 &amp; f &amp; v_0 \\ 0 &amp; 0 &amp; 1\end{array}\right)\)</span></p><p>外参旋转矩阵 <span class="math inline">\(R\)</span> ：</p><p><span class="math inline">\(R =\displaystyle \left(\begin{array}{ccc}R_{1,1}  &amp; R_{1,2}  &amp; R_{1,3} \\ R_{2,1}  &amp; R_{2,2}  &amp;R_{2,3} \\ R_{3,1}  &amp; R_{3,2}  &amp;R_{3,3}  \end{array}\right)\)</span></p><p>外参平移向量 <span class="math inline">\(t\)</span> ：</p><p><span class="math inline">\(t =\displaystyle \left(\begin{array}{c}t_1 \\ t_2 \\ t_3  \end{array}\right)\)</span></p><p>世界坐标点 <span class="math inline">\(X\)</span> ：</p><p><span class="math inline">\(X =\displaystyle \left(\begin{array}{c}X_1 \\ X_2 \\ X_3  \end{array}\right)\)</span></p><p>像点坐标 <span class="math inline">\(x\)</span> ： <spanclass="math inline">\(x =\displaystyle \left(\begin{array}{c} x_1 \\x_2  \end{array}\right)\)</span></p><p><span class="math inline">\(express1 =\displaystyle\left(\begin{array}{c} f\,t_1 +t_3 \,u_0 +X_1 \,{\left(R_{1,1}\,f+R_{3,1} \,u_0 \right)}+X_2 \,{\left(R_{1,2} \,f+R_{3,2} \,u_0\right)}+X_3 \,{\left(R_{1,3} \,f+R_{3,3} \,u_0 \right)}\\ f\,t_2 +t_3\,v_0 +X_1 \,{\left(R_{2,1} \,f+R_{3,1} \,v_0 \right)}+X_2\,{\left(R_{2,2} \,f+R_{3,2} \,v_0 \right)}+X_3 \,{\left(R_{2,3}\,f+R_{3,3} \,v_0 \right)}\\ t_3 +R_{3,1} \,X_1 +R_{3,2} \,X_2 +R_{3,3}\,X_3  \end{array}\right)\)</span></p><p><span class="math inline">\(express2 =\displaystyle \begin{array}{l}\left(\begin{array}{c} \frac{f\,t_1 +t_3 \,u_0 +X_1 \,{\left(R_{1,1}\,f+R_{3,1} \,u_0 \right)}+X_2 \,{\left(R_{1,2} \,f+R_{3,2} \,u_0\right)}+X_3 \,{\left(R_{1,3} \,f+R_{3,3} \,u_0 \right)}}{\sigma_1 }-x_1\\ \frac{f\,t_2 +t_3 \,v_0 +X_1 \,{\left(R_{2,1} \,f+R_{3,1} \,v_0\right)}+X_2 \,{\left(R_{2,2} \,f+R_{3,2} \,v_0 \right)}+X_3\,{\left(R_{2,3} \,f+R_{3,3} \,v_0 \right)}}{\sigma_1}-x_2  \end{array}\right)\\\mathrm{}\,\\{where}\\\sigma_1 =t_3 +R_{3,1}\,X_1 +R_{3,2} \,X_2 +R_{3,3} \,X_3 \end{array}\)</span></p><p>把 <span class="math inline">\(t_1 ,t_2 ,t_3\)</span>从上述公式独立出来，令express2=0，重新整理可得到下式：</p><p><span class="math inline">\(\left\lbrack \begin{array}{ccc} f &amp; 0&amp; u_0 -x_1 \\ 0 &amp; f &amp; v_0 -x_2  \end{array}\right\rbrack\left\lbrack \begin{array}{c} t_1 \\ t_2 \\t_3  \end{array}\right\rbrack =\left\lbrack \begin{array}{c} x_1\left(R_{3,1} X_1 +R_{3,2} X_2 +R_{3,3} X_3 \right)-X_1 \left(R_{1,1}f+R_{3,1} u_0 \right)-X_2 \left(R_{1,2} f+R_{3,2} u_0 \right)-X_3\left(R_{1,3} f+R_{3,3} u_0 \right)\\ x_2 \left(R_{3,1} X_1 +R_{3,2} X_2+R_{3,3} X_3 \right)-X_1 \left(R_{2,1} f+R_{3,1} v_0 \right)-X_2\left(R_{2,2} f+R_{3,2} v_0 \right)-X_3 \left(R_{2,3} f+R_{3,3} v_0\right) \end{array}\right\rbrack\)</span> (6a)</p><p>为便于从形式上公式简化，把上式写成如下形式：</p><p><span class="math inline">\(\left\lbrack \begin{array}{ccc} f &amp; 0&amp; u_0 -x_1 \\ 0 &amp; f &amp; v_0 -x_2  \end{array}\right\rbrack\left\lbrack \begin{array}{c} t_1 \\ t_2 \\t_3  \end{array}\right\rbrack =\left\lbrack \begin{array}{c} r_3 P_w\left(x_1 -u_0 \right)-f\left(r_1 P_w \right)\\ r_3 P_w \left(x_2 -v_0\right)-f\left(r_2 P_w \right) \end{array}\right\rbrack\)</span> ，(6b)</p><p>其中： <span class="math inline">\(r_i =\left\lbrack R_{i,1} ,R_{i,2},R_{i,3} \right\rbrack ,P_w =\left\lbrack \begin{array}{c} X_1 \\ X_2 \\X_3  \end{array}\right\rbrack\)</span>,其余都为标量值。工程上计算直接使用(6a)式，svd求解即可。</p><ul><li>几何方法：</li></ul><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/cameraProject1.jpg"alt="Fig1.实际立体图（相机像素坐标系下）" /><figcaptionaria-hidden="true">Fig1.实际立体图（相机像素坐标系下）</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/cameraProject3.jpg"alt="Fig2.实际立体成像图（相机像素坐标)" /><figcaptionaria-hidden="true">Fig2.实际立体成像图（相机像素坐标)</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/birdView3.jpg"alt="Fig3.实际俯视图（相机像素坐标系下）" /><figcaptionaria-hidden="true">Fig3.实际俯视图（相机像素坐标系下）</figcaption></figure><p><strong>数学背景</strong>：已知空间中三角形 <spanclass="math inline">\(\bigtriangleup \textrm{PMN}\)</span>的三个顶点坐标分别为 <span class="math inline">\(P\left(x_0 ,y_0 ,z_0\right),M\left(x_1 ,y_1 ,z_1 \right),N\left(x_2 ,y_2 ,z_2\right)\)</span> ，该三角形所在平面为 <spanclass="math inline">\(\psi\)</span> ，位于该平面内过一顶点P的方向向量为<span class="math inline">\(l=\left(l_1 ,l_2 ,l_3 \right)\)</span>，该向量不与此三角形任何边平行/重合，则过点M且平行于方向向量 <spanclass="math inline">\(l\)</span> 的直线 <spanclass="math inline">\(\textrm{MQ}\)</span> 必与 <spanclass="math inline">\(\textrm{PN}\)</span> 所在直线相交，交点为 <spanclass="math inline">\(Q\left(x,y,z\right)\)</span>，其示意图和解析解如下：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/mathD.jpg"alt="Fig4.求解Q点示意图" /><figcaption aria-hidden="true">Fig4.求解Q点示意图</figcaption></figure><p>由已知平行性条件，可得下面共面的两条空间直线方程组：</p><p><span class="math display">\[ \left\lbrace \begin{array}{ll}\frac{x-x_1 }{l_1 }=\frac{y-y_1 }{l_2 }=\frac{z-z_1 }{l_3 } &amp; \\\frac{x-x_2 }{x_2 -x_0 }=\frac{x-x_2 }{y_2 -y_0 }=\frac{x-x_2 }{z_2 -z_0} &amp;  \end{array}\right. \]</span></p><p><span class="math inline">\(Q = \displaystyle \begin{array}{l}\left(\begin{array}{ccc} \sigma_1  &amp; \frac{l_2 \,x_1 \,y_0 +l_2\,x_0 \,y_2 -l_2 \,x_2 \,y_0 -l_2 \,x_1 \,y_2 -l_1 \,y_0 \,y_1 +l_1\,y_1 \,y_2 }{l_2 \,x_0 -l_2 \,x_2 -l_1 \,y_0 +l_1 \,y_2 } &amp; z_1-\frac{l_3 \,{\left(x_1 -\sigma_1 \right)}}{l_1 }\end{array}\right)\\\mathrm{}\\\textrm{where}\\\mathrm{}\\\;\;\sigma_1=\frac{l_2 \,x_0 \,x_1 -l_2 \,x_1 \,x_2 -l_1 \,x_0 \,y_1 +l_1 \,x_0\,y_2 -l_1 \,x_2 \,y_0 +l_1 \,x_2 \,y_1 }{l_2 \,x_0 -l_2 \,x_2 -l_1\,y_0 +l_1 \,y_2 }\end{array}\)</span></p><p>实现函数为calQcoord.m。</p><p>主要利用相似三角形计算，由Fig2中成像过程，可知 <spanclass="math inline">\(\bigtriangleup \textrm{PMQ}\sim \bigtriangleup{\textrm{PM}}_w N_w\)</span> ，点 <spanclass="math inline">\(M_w\)</span> 、 <spanclass="math inline">\(N_w\)</span> 分别为图像中 <spanclass="math inline">\(M\)</span> 、 <spanclass="math inline">\(N\)</span>点对应世界坐标系中的点，因在世界坐标系中 <spanclass="math inline">\(\left\|\textrm{MN}\right\|\)</span>模已知，故可求解 <span class="math inline">\(M\)</span>点的深度，从而推出外参 <span class="math inline">\(T\)</span>，详细见demoOneImgCalibrate.m实现。</p><p>参考：</p><ol type="1"><li><ahref="https://github.com/cuixing158/singleImageCalibration/blob/main/calIntrinsicGeometricAnalysis.md#利用直角四面体性质求解（推荐）">基于几何方法的单张图像标定之相机内参数学分析</a></li><li><ahref="https://github.com/cuixing158/singleImageCalibration/blob/main/calExtrinsicAnalysis.md#计算相机内参k">基于代数和几何方法的单张图像线性标定分析和实现</a></li></ol><h3 id="基于光束平差法的外参标定方法">3.5基于光束平差法的外参标定方法</h3><p>为了求解相机的位姿(R,t)和空间三维点的3D坐标，常采用优化的方式，优化方法中常用的是光束平差法（BA，又叫捆绑调整，束调整等）。BA方法的核心是最小化重投影误差，即有一个图像中的2D点m，算得一个三维点初始的3D坐标P时，将三维点重新投影到图像平面得到m'，最小化原始图像点m与重投影回去的m'之间（所有图像所有对应的图像点）的误差。可以看出，最小化投影误差，是一个非线性最小二乘问题。非线性最小二乘问题求解，常采用的方法是线性化，即使用泰勒展开式展开，忽略高阶项，变成线性最小二乘问题。</p><h3 id="摄像机和激光雷达的联合标定">3.6 摄像机和激光雷达的联合标定</h3><h3 id="其他标定方法">3.7 其他标定方法</h3><h2 id="特征提取与匹配-1">4.特征提取与匹配</h2><h3 id="图像梯度信息">4.1 图像梯度信息</h3><h3 id="特征点提取">4.2 特征点提取</h3><h3 id="特征匹配">4.3 特征匹配</h3><h2 id="由运动恢复结构sfm">5.由运动恢复结构SFM</h2><h3 id="对极几何">5.1 对极几何</h3><h3 id="二视图重建">5.2 二视图重建</h3><h3 id="光束法平差">5.3 光束法平差</h3><h2 id="双目立体视觉">6.双目立体视觉</h2><h3 id="双目视觉系统介绍">6.1 双目视觉系统介绍</h3><h3 id="密集匹配">6.2 密集匹配</h3><h3 id="结构光三维成像">6.3 结构光三维成像</h3><h2 id="三维点云滤波与表面建模">7.三维点云滤波与表面建模</h2><h3 id="三维点云的基本特征">7.1 三维点云的基本特征</h3><h3 id="点云数据空间结构增强">7.2 点云数据空间结构增强</h3><h3 id="表面建模概念和方法">7.3 表面建模概念和方法</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Cpp调试-GDB的安装与使用</title>
    <link href="/2024/01/04/Cpp%E8%B0%83%E8%AF%95-GDB%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/01/04/Cpp%E8%B0%83%E8%AF%95-GDB%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基于单目视觉的三维重建</title>
    <link href="/2024/01/04/%E5%9F%BA%E4%BA%8E%E5%8D%95%E7%9B%AE%E8%A7%86%E8%A7%89%E7%9A%84%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA/"/>
    <url>/2024/01/04/%E5%9F%BA%E4%BA%8E%E5%8D%95%E7%9B%AE%E8%A7%86%E8%A7%89%E7%9A%84%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基于车道线的道路标定</title>
    <link href="/2023/12/26/%E5%9F%BA%E4%BA%8E%E8%BD%A6%E9%81%93%E7%BA%BF%E7%9A%84%E9%81%93%E8%B7%AF%E6%A0%87%E5%AE%9A/"/>
    <url>/2023/12/26/%E5%9F%BA%E4%BA%8E%E8%BD%A6%E9%81%93%E7%BA%BF%E7%9A%84%E9%81%93%E8%B7%AF%E6%A0%87%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1id="基于车道线的cam2vehicle道路标定">基于车道线的Cam2vehicle道路标定</h1><p>1.pitch角的标定：基于假设，车道线线平行，车体和路面平行（车子没有抖动），车道线像素投影到地面为平行的3D点。</p><ul><li><em>怎么判断车子当前是平稳的状态？</em></li></ul><p>优化标量：pitch</p><p>目标函数：车道线地面投影3D点平行。（车道线地面投影的夹角。优化目标夹角为0）</p><p><strong>优化</strong>过程：修改pitch-&gt;R矩阵-&gt;引入鱼眼原图-&gt;3D-&gt;平行判断</p><p>2.roll角度：车道线等宽、灯杆垂直地面（或者有第三方车道线真值提供）；</p><ul><li><em>怎么准确检测车道线的边缘</em></li><li><em>怎么检测灯杆轴线</em></li></ul><p>3.yaw:多帧判断车子直行，计算车道线投影点和X方向夹角</p><p>多帧<strong>优化</strong>yaw角，使得所有点在一条直线上；</p><p>通过标志牌测距，优化yaw角，结合单目中用内参计算标志牌的距离。结合里程计，标志牌在的x方向的位移等于行进里程。</p><ul><li><em>怎么结合单目中用内参计算标志牌的距离</em></li></ul><p>参考</p><p><ahref="https://cloud.tencent.com/developer/article/1673568">算法集锦（18）| 自动驾驶 | 车道线检测算法-腾讯云开发者社区-腾讯云(tencent.com)</a></p><p>在HSV空间隔离车道线，效果很糟糕，白色车道线和灰暗地面无法分辨、</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20231226193154167.png"alt="使用HSV隔离车道线" /><figcaption aria-hidden="true">使用HSV隔离车道线</figcaption></figure><p>在HSL颜色空间处理。由于车道线通常为黄、白二色，所以设置黄白阈值对车道线进行处理。受到相机ISP以及实际场景路面的粗糙度、污渍、灰尘以及车道线的破损程度印象影响，仍然无法得到一组泛化能力较高得阈值。</p><p>下图使用hsl空间的黄白阈值对图像进行筛选后再融合，融合后进行灰度化处理。由于融合图像中有大量0值黑块，0值黑块影响了二值化自适应阈值的计算，因此在进行二值化阈值计算的过程中应尽量排除黑色区域的影响。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20240104103145360.png"alt="hsl空间筛选黄白车道线后进行二值化处理" /><figcaptionaria-hidden="true">hsl空间筛选黄白车道线后进行二值化处理</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>自动驾驶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>在线标定</tag>
      
      <tag>环视相机</tag>
      
      <tag>车道线检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git CI/CD搭建自动化编译</title>
    <link href="/2023/12/18/Git-CI-CD%E6%90%AD%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E5%B9%B3%E5%8F%B0/"/>
    <url>/2023/12/18/Git-CI-CD%E6%90%AD%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在大型的开源项目或者软件开发过程中，很多开发者都会去提交<code>PR</code>或者进行代码的<code>push</code>操作。如果对于每次代码合并都需要项目的核心维护者进行<code>code review</code>，这项工作是及其困难而且耗时的。因此许多团队都会指定一套代码规范,然后编写测试用例严格的检查每次代码修改，这样能够非常有效的减少后期代码维护的成本。</p><p>现在，基于<strong>githubaction</strong>, 我们可以自动化的完成代码的<code>CI/CD</code> 工作流。­<strong>Githubaction</strong>是 GitHub推出的持续集成 (Con­tin­u­ous in­te­gra­tion，简称 CI)服务，它提供了配置非常不错的虚拟服务器环境，基于它可以进行构建、测试、打包、部署项目。</p><p>Github Actions 的最大优势就是它是与 GitHub高度整合的，只需一个配置文件即可自动开启服务。甚至你不需要购买服务器 ——GitHub Actions自带云环境运行，包括私有仓库也可以享用，而且云环境性能也非常不错。</p><p>本篇文章将介绍 GitHub Ac­tions 的基本使用方法。</p><h3 id="ci-continuous-integration">CI (Continuous integration)</h3><p>互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuousintegration，简称CI）</p><h4 id="概念">概念</h4><p>持续集成指的是，频繁地（一天多次）将代码集成到主干。它的好处主要有两个</p><ul><li>快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。</li><li>防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。</li></ul><p>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p><h4 id="持续交付">持续交付</h4><p>持续交付（Continuousdelivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。</p><h4 id="持续部署">持续部署</h4><p>持续部署（continuousdeployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。</p><p>持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。</p><h4 id="流程">流程</h4><p>根据持续集成的设计，代码从提交到生产，整个过程有以下几步。</p><p>（1）提交</p><p>流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交（commit）。</p><p>（2）测试（第一轮）</p><p>代码仓库对commit操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。测试有好几种。</p><ul><li>单元测试：针对函数或模块的测试</li><li>集成测试：针对整体产品的某个功能的测试，又称功能测试</li><li>端对端测试：从用户界面直达数据库的全链路测试</li></ul><ol start="3" type="1"><li>构建</li></ol><p>通过第一轮测试，代码就可以合并进主干，就算可以交付了。交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。常用的构建工具如下。</p><ul><li>Jenkins</li><li>Travis</li><li>Codeship</li><li>Strider</li></ul><ol start="4" type="1"><li>测试（第二轮）</li></ol><p>构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。</p><p>第二轮是全面测试，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。</p><p>需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。</p><ol start="5" type="1"><li>部署</li></ol><p>通过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（tar filename.tar * ）存档，发到生产服务器。</p><ol start="6" type="1"><li>回滚</li></ol><p>一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>项目工程管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用Git操作</title>
    <link href="/2023/12/18/%E5%B8%B8%E7%94%A8Git%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/12/18/%E5%B8%B8%E7%94%A8Git%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="常用git-操作">常用Git 操作</h2><h3 id="git-强制回退删除已提交慎用">1.git强制回退，删除已提交（<strong><em>慎用</em></strong>）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git reset --hard commit_id<br>git push --force origin 3dod<br></code></pre></td></tr></table></figure><h3 id="git-本地仓库关联远程仓库">2.git 本地仓库关联远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git remote <span class="hljs-comment"># 查看当前有哪些远程仓库</span><br>git remote -v <span class="hljs-comment"># 列出当前仓库中已配置的远程仓库，并显示它们的 URL</span><br>git remote add &lt;本地仓库名&gt; &lt;远程仓库url&gt;  <span class="hljs-comment"># 本地仓库关联远程仓库</span><br>git remote <span class="hljs-built_in">rm</span>  &lt;远程仓库别名&gt;  <span class="hljs-comment"># 删除远程仓库</span><br></code></pre></td></tr></table></figure><h3 id="git分支操作">3.Git分支操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git branch                  <span class="hljs-comment"># 查看分支</span><br>git branch  (branchname)     <span class="hljs-comment"># 创建新分支(branchname) </span><br>git checkout -b (branchname) <span class="hljs-comment"># 创建新分支并(branchname) 立即切换到该分支</span><br>git checkout (branchname)   <span class="hljs-comment"># 可以切换到分支(branchname) </span><br>git branch -d (branchname)  <span class="hljs-comment"># 可以删除分支(branchname) </span><br></code></pre></td></tr></table></figure><h3 id="git-本地仓库添加暂存文件">4.Git 本地仓库添加暂存文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git add &lt;文件1&gt; &lt;文件1&gt; &lt;文件2&gt; &lt;文件3&gt; ...<br></code></pre></td></tr></table></figure><h3 id="git-命令来查看相关文件的状态查看更新的详细信息">5.Git命令来查看相关文件的状态/查看更新的详细信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git status   <span class="hljs-comment"># 查看相关文件的状态</span><br>git diff     <span class="hljs-comment"># 查看尚未缓存的改动更新的详细信息</span><br>git diff --cached  <span class="hljs-comment"># 查看已缓存的改动： </span><br>git diff HEAD      <span class="hljs-comment"># 查看已缓存的与未缓存的所有改动：</span><br>git diff --<span class="hljs-built_in">stat</span>    <span class="hljs-comment"># 显示摘要而非整个 diff</span><br></code></pre></td></tr></table></figure><h3 id="git-取消已缓存的内容">6.Git 取消已缓存的内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git reset HEAD test.txt   <span class="hljs-comment"># 用于取消已缓存的内容，如我们要取消已提交的test.txt文件.执行完之后，再使用commit提交时，test.txt文件不会被提交。</span><br></code></pre></td></tr></table></figure><h3 id="git-提交暂存文件">7.Git 提交暂存文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git commit -m <span class="hljs-string">&quot;&lt;提交说明&gt;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="git-提交修改到远程仓库">8.Git 提交修改到远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git push &lt;本地仓库名&gt; &lt;远程分支名&gt;<br></code></pre></td></tr></table></figure><h3 id="git-拉取远程仓库">9.Git 拉取远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git pull  <span class="hljs-comment">#相当于是从远程获取最新版本并merge到本地</span><br>git fetch  <span class="hljs-comment"># 相当于是从远程获取最新版本到本地，不会自动合并。</span><br></code></pre></td></tr></table></figure><h3 id="git合并操作">10.Git合并操作</h3><p>合并的时候，最大的难点就是冲突了，合并并不仅仅是简单的文件添加、移除的操作，Git也会合并修改，如果我们在两个分支中同时修改了同一个文件，这时再合并，就可能会产生冲突，冲突并不可怕，可怕的是要怎样去解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git merge branchname <span class="hljs-comment">#将任意分支合并到到当前分支中</span><br></code></pre></td></tr></table></figure><h3 id="git查看提交历史">11.Git查看提交历史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git <span class="hljs-built_in">log</span> <span class="hljs-comment"># 命令查看</span><br>git –oneline <span class="hljs-comment"># 查看历史记录的简洁版本</span><br>git –graph <span class="hljs-comment"># 查看历史中什么时候出现了分支、合并</span><br>git –reverse <span class="hljs-comment"># 逆向显示所有日志</span><br>git –author <span class="hljs-comment"># 查找指定用户的提交日志</span><br>git –since、–before、 --<span class="hljs-keyword">until</span>、–after <span class="hljs-comment"># 指定筛选日期</span><br>git –no-merges <span class="hljs-comment"># 选项以隐藏合并提交</span><br>git <span class="hljs-built_in">log</span> --autho <span class="hljs-comment"># 查找指定用户的提交日志</span><br></code></pre></td></tr></table></figure><h3 id="git-标签操作">12.Git 标签操作</h3><p>使用标签可以很方便的永远的记住那个特别的提交快照，比如：我们发一个新的版本时，可以给它加一个“vx.x”版本，这样你可以使用gittag给它打上标签。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git tag -a v1.0 <span class="hljs-comment"># 创建一个带注解的标签,可以很方便的永远的记住那个特别的提交快照</span><br>git tag <span class="hljs-comment"># 查看标签</span><br>git tag -a &lt;tagname&gt; -m <span class="hljs-string">&quot;某某标签&quot;</span> <span class="hljs-comment">#指定标签信息</span><br>git tag -a v1.0 d6f7147 <span class="hljs-comment"># d6f7147提交已发布，可对其追加标签 </span><br>git checkout tag_name <span class="hljs-comment"># 但是，这时候 git 可能会提示你当前处于一个“detached HEAD&quot; 状态。因为 tag 相当于是一个快照，是不能更改它的代码的。如果要在 tag 代码的基础上做修改，你需要一个分支： git checkout -b branch_name tag_name</span><br></code></pre></td></tr></table></figure><h3 id="配置.gitignore文件">13.<code>配置.gitignore</code>文件</h3><p>把要忽略的文件名填进去，Git就会自动忽略这些文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 忽略所有.开头的隐藏文件:</span><br>.*<br><span class="hljs-comment"># 忽略所有.class文件:</span><br>*.class<br><br><span class="hljs-comment"># 排除忽略.gitignore和App.class:</span><br>!.gitignore<br>!App.class<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>项目工程管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更有效的更积极的工作生活</title>
    <link href="/2023/12/18/%E6%9B%B4%E6%9C%89%E6%95%88%E7%9A%84%E6%9B%B4%E7%A7%AF%E6%9E%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%94%9F%E6%B4%BB/"/>
    <url>/2023/12/18/%E6%9B%B4%E6%9C%89%E6%95%88%E7%9A%84%E6%9B%B4%E7%A7%AF%E6%9E%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%94%9F%E6%B4%BB/</url>
    
    <content type="html"><![CDATA[<p>更有效的更积极的工作生活</p><p>《孟子.滕文公章句上》中提到”劳心者治人，劳力者治于人；治于人者食人，治人者食于人；天下之通义也。“</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安装paddle-gpu后找不到动态链接库libcuda.so</title>
    <link href="/2023/12/10/%E5%AE%89%E8%A3%85paddle-gpu%E5%90%8E%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93libcuda-so/"/>
    <url>/2023/12/10/%E5%AE%89%E8%A3%85paddle-gpu%E5%90%8E%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93libcuda-so/</url>
    
    <content type="html"><![CDATA[<h1id="安装paddle-gpu后找不到动态链接库libcuda.so">安装<strong>paddle-gpu</strong>后找不到动态链接库libcuda.so</h1><p>按照文档安装<strong>paddle-gpu</strong>后，<strong>paddle-gpu</strong>不能正常运行，并报错。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import paddle</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; paddle.utils.run_check()</span><br>Running verify PaddlePaddle program ...<br>I1209 22:43:10.566331  2436 interpretercore.cc:237] New Executor is Running.<br>W1209 22:43:10.566608  2436 gpu_resources.cc:119] Please NOTE: device: 0, GPU Compute Capability: 8.6, Driver API Version: 12.0, Runtime API Version: 11.8<br>W1209 22:43:10.585208  2436 gpu_resources.cc:149] device: 0, cuDNN Version: 8.6.<br>W1209 22:43:12.852262  2436 dynamic_loader.cc:303] The third-party dynamic library (libcuda.so) that Paddle depends on is not configured correctly. (error code is libcuda.so: cannot open shared object file: No such file or directory)<br>  Suggestions:<br>  1. Check if the third-party dynamic library (e.g. CUDA, CUDNN) is installed correctly and its version is matched with paddlepaddle you installed.<br>  2. Configure third-party dynamic library environment variables as follows:<br>  - Linux: set LD_LIBRARY_PATH by `export LD_LIBRARY_PATH=...`<br>  - Windows: set PATH by `set PATH=XXX;<br><br></code></pre></td></tr></table></figure><ul><li>首先从log 的提示中，可以看出是无法链接到<strong>libcuda.so</strong>文件，先查找<strong>libcuda.so</strong>文件的位置。作为动态链接库一般都安装在<code>/usr/</code>文件夹下。在<code>/usr/</code>文件夹下查找<strong>libcuda.so</strong>文件,其路径为<code>/usr/lib/wsl/lib/libcuda.so</code>。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">user@unutu:sudo find /usr/ -name &quot;libcuda.so&quot;<br>/usr/lib/wsl/lib/libcuda.so<br></code></pre></td></tr></table></figure><p>在这里补充一下，我是在conda的子环境<strong>env_paddle</strong>中安装了paddle-gpu。因此需要将子环境<strong>env_paddle</strong>的库路径<code>～/miniconda3/envs/env_paddle/lib/</code> 在<code>～/.bashrc</code>中加入到环境变量，使用指令<code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:~/miniconda3/envs/env_paddle/lib/</code>。</p><ul><li>然后在环境变量下创建软连接，具体用法是：<code>ln -s  [源文件]  [软链接文件]</code>。这样paddle就能在环境变量下链接到到<strong>libcuda.so</strong>文件。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s  /usr/lib/wsl/lib/libcuda.so  ~/miniconda3/envs/env_paddle/lib/libcuda.so<br></code></pre></td></tr></table></figure><ul><li>在shell中输入<code>python -c "import paddle; paddle.utils.run_check()"</code>，提示<code>PaddlePaddle is installed successfully!</code>。则问题已解决。</li></ul>]]></content>
    
    
    <categories>
      
      <category>日常部署排故</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>paddle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在线标定_前后帧三角测量</title>
    <link href="/2023/12/06/%E5%9C%A8%E7%BA%BF%E6%A0%87%E5%AE%9A-%E5%89%8D%E5%90%8E%E5%B8%A7%E4%B8%89%E8%A7%92%E6%B5%8B%E9%87%8F/"/>
    <url>/2023/12/06/%E5%9C%A8%E7%BA%BF%E6%A0%87%E5%AE%9A-%E5%89%8D%E5%90%8E%E5%B8%A7%E4%B8%89%E8%A7%92%E6%B5%8B%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>sdasadsad</p>]]></content>
    
    
    <categories>
      
      <category>自动驾驶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>在线标定</tag>
      
      <tag>环视相机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo+github+windows搭建个人博客</title>
    <link href="/2023/12/06/hexo-github-windows%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/12/06/hexo-github-windows%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1id="hexogithubwindows搭建个人博客">hexo+github+windows搭建个人博客</h1><p>对于搭载免费的静态网页，gitee是个不错的选择。但由于gitee需要实名备案，最终选择github来搭载个人博客的静态网页。但github上的page只支持public仓库，且支持为一个静态网页I/O，且静态网页仓库名必须命名为<strong><em>用户名</em></strong>.github.io。而且通过page功能发布的网页网址定义为https://<strong><em>用户名</em></strong>.github.io/。</p><h2 id="个人博客的搭建从无到有">个人博客的搭建：从无到有</h2><h3 id="第一步github-page搭建">第一步：GitHub Page搭建</h3><p>1、在Github新建一个仓库，命名为:<strong><em>用户名</em></strong>.github.io</p><p>2、 启用GitHub Page：</p><p>点击“Setting”菜单进入设置</p><p>首先点击”Launch automatic page generator”</p><h3 id="第二步安装hexo">第二步：安装Hexo</h3><ol type="1"><li>安装npm</li><li>安装git</li><li>安装hexo</li></ol><h3 id="第二步使用图床">第二步：使用图床</h3><h5 id="使用github-仓库作为图床">1. 使用github 仓库作为图床</h5><p>总得需要一个放图片和视频等东西的地方，比较小的可以直接放到 GitHub上，但是 repository 目前有 <strong>≤1GB</strong> 的限制。</p><ol type="1"><li>准备一个 Github 账号；</li><li>搭建Github图床仓库，确保仓库为 <code>public</code> ；</li><li>上传图片设置（Github 创建一个 token; 配置 PicGo，依次打开 图床设置-&gt; Github 图床;）</li><li>加速访问（PicGo设置使用 <ahref="https://link.zhihu.com/?target=https%3A//www.jsdelivr.com/">jsDelivr</a>进行免费加速）；</li><li>typora测试自动上传图床</li></ol><h5 id="使用其他图床">2.使用其他图床</h5><p>除开用 Github 搭建的方式之后，我们也可以用 Gitee进行搭建，搭建方式和本文大致相同。此外，我也推荐几个免费的图床给大家，大家可以根据自己的喜好进行选择；</p><ol type="1"><li><ahref="https://link.zhihu.com/?target=https%3A//imgchr.com/">路过图床</a></li><li><ahref="https://link.zhihu.com/?target=https%3A//sm.ms/">SM.MS</a></li><li><ahref="https://link.zhihu.com/?target=https%3A//imgur.com/">Imgur</a></li></ol><h3 id="第三步安装fluid主题示例">第三步：安装fluid主题示例</h3><p>Fluid 是基于 Hexo 的一款 Material Design 风格的主题，由 <ahref="https://github.com/fluid-dev">Fluid-dev (opens newwindow)</a>负责开发与维护。用户手册见<ahref="https://fluid-dev.github.io/hexo-fluid-docs/start/">开始使用 |Hexo Fluid 用户手册 (fluid-dev.github.io)</a></p><p>安装教程见:<ahref="https://fluid-dev.github.io/hexo-fluid-docs/start/#安装主题">开始使用| Hexo Fluid 用户手册 (fluid-dev.github.io)</a></p><h3 id="第四步配置本地公式">第四步：配置本地公式</h3><p>hexo默认使用 Markdown渲染器渲染latex数学公式，对于一些大型矩阵的复杂公式的并不支持，因此需要更换渲染器（mathjax可选择性更换）。需要安配置不同的<code>engine</code>，（比如mathjax或者katex）。并对<code>主题配置</code>进行修改。</p><blockquote><p>"站点配置" 指的 Hexo 博客目录下的 _config.yml，"主题配置" 指的是theme/fluid/_config.yml 或者 <em>config.fluid.yml，注意区分（实际操作时，建议修改</em>_config.fluid.yml ）；</p></blockquote><p><strong>设置主题配置</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">math:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br></code></pre></td></tr></table></figure><blockquote><p><code>specific</code>: 建议开启。当为 true 时，只有在文章 <ahref="https://hexo.io/zh-cn/docs/front-matter">front-matter (opens newwindow)</a>里指定(如果使用mathjax渲染器)<code>mathjax: true</code>才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度。</p></blockquote><p><strong>更换 Markdown 渲染器</strong></p><p>由于 Hexo 默认的 Markdown渲染器不支持复杂公式，所以需要更换渲染器（mathjax 可选择性更换）。</p><p>然后根据上方配置不同的 <code>engine</code>，推荐更换如下渲染器：</p><blockquote><p>mathjax</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm uninstall hexo-renderer-marked --save <span class="hljs-comment"># 先将原有的渲染器卸载</span><br>npm install hexo-renderer-pandoc --save   <span class="hljs-comment"># 安装pandoc</span><br></code></pre></td></tr></table></figure><p><strong>并且还需<ahref="https://github.com/jgm/pandoc/blob/master/INSTALL.md">安装Pandoc</a></strong>，安装完后，记得电脑重启一下。</p></blockquote><h3 id="section"></h3><h2id="本地端个人博客在不同设备端的同步与迁移">本地端个人博客在不同设备端的同步与迁移</h2><p>上一节中，在本地创建了hexo项目的目录。其目录结构如下</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20240104095217144.png"alt="image-20240104095217144" /><figcaption aria-hidden="true">image-20240104095217144</figcaption></figure><p>在目录下使用<code>git status</code>，提示<code>fatal: Not a git repository (or any of the parent directories): .git</code>。显然，hexo项目不是以git仓库的形式与github.io保持同步的。</p><p>因此，当前项目跟一个远程仓库关联起来，好管理环境文件。为了保证文件安全，建立一个hexo分支与main分支区别。把hexo分支pull到本地进行修改，每次修改完本地仓库后，再push到hexo分支，再将两个分支merge。但是repository 目前有 <strong>≤1GB</strong>的限制,branch会占用容量。所以也可以新建额外的仓库用来同步。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/4906139-652af9cbae0a1a3d.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="参考">参考</h2><p>1.<ahref="https://kaiboshi.gitee.io/posts/ccdb282h.html#:~:text=1%20直接在Hexo根目录执行%20gulp%20或者%20gulp%20default%20，这个命令相当于%20hexo,2%20在Hexo根目录执行%20gulp%20build%20，这个命令与第1种相比是：在最后又加了个%20hexo%20d%20，等于说生成、压缩文件后又帮你自动部署了。">Hexo博客主题安装和优化（五）优化图片，代码| Kaiboshiの博客 (gitee.io)</a></p><p>2.<ahref="https://tangh.github.io/articles/hexo-with-github-pages-static-site/">Hexo+ GitHub Pages 静态网站 - 雨天等放晴 (tangh.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bash大法好</title>
    <link href="/2023/12/04/Bash%E5%A4%A7%E6%B3%95%E5%A5%BD/"/>
    <url>/2023/12/04/Bash%E5%A4%A7%E6%B3%95%E5%A5%BD/</url>
    
    <content type="html"><![CDATA[<p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell既是一种命令语言，又是一种程序设计语言。</p><ol type="1"><li><h2 id="ffmpeg-处理视频文件的一些操作">ffmpeg处理视频文件的一些操作</h2></li></ol><p>在172.16.2.88服务器上，/data01/ffmpeg-n5.1-latest-linux64-lgpl-shared-5.1.tar.gz是一个比较新的ffmpeg版本，该版本可以使用n卡做编解码器，也就是是-chevc_nvenc参数加速处理。</p><p>该版本包含：(decoders: hevc hevc_qsv hevc_cuvid ) (encoders: hevc_amfhevc_nvenc hevc_qsv hevc_vaapi libkvazaar)，hevc_amf是amd集成显卡的编码器，hevc_qsv是intel集成显卡的编码器。</p><ol type="1"><li><h3 id="常用参数来自网络">常用参数（来自网络）</h3></li></ol><table><thead><tr class="header"><th>基本选项:</th><th></th></tr></thead><tbody><tr class="odd"><td>-formats</td><td>输出所有可用格式</td></tr><tr class="even"><td>-f fmt</td><td>指定格式(音频或视频格式)</td></tr><tr class="odd"><td>-i filename</td><td>指定输入文件名，在linux下当然也能指定:0.0(屏幕录制)或摄像头</td></tr><tr class="even"><td>-y</td><td>覆盖已有文件</td></tr><tr class="odd"><td>-t duration</td><td>记录时长为t</td></tr><tr class="even"><td>-fs limit_size</td><td>设置文件大小上限</td></tr><tr class="odd"><td>-ss time_off</td><td>从指定的时间(s)开始， [-]hh:mm:ss[.xxx]的格式也支持</td></tr><tr class="even"><td>-itsoffset time_off</td><td>设置时间偏移(s)，该选项影响所有后面的输入文件。该偏移被加到输入文件的时戳，定义一个正偏移意味着相应的流被延迟了offset秒。 [-]hh:mm:ss[.xxx]的格式也支持</td></tr><tr class="odd"><td>-title string</td><td>标题</td></tr><tr class="even"><td>-timestamp time</td><td>时间戳</td></tr><tr class="odd"><td>-author string</td><td>作者</td></tr><tr class="even"><td>-copyright string</td><td>版权信息</td></tr><tr class="odd"><td>-comment string</td><td>评论</td></tr><tr class="even"><td>-album string</td><td>album名</td></tr><tr class="odd"><td>-v verbose</td><td>与log相关的</td></tr><tr class="even"><td>-target type</td><td>设置目标文件类型("vcd", "svcd", "dvd", "dv", "dv50", "pal-vcd","ntsc-svcd", ...)</td></tr><tr class="odd"><td>-dframes number</td><td>设置要记录的帧数</td></tr></tbody></table><table><thead><tr class="header"><th>视频选项:</th><th></th></tr></thead><tbody><tr class="odd"><td>-b</td><td>指定比特率(bits/s)，似乎ffmpeg是自动VBR的，指定了就大概是平均比特率</td></tr><tr class="even"><td>-bitexact</td><td>使用标准比特率</td></tr><tr class="odd"><td>-vb</td><td>指定视频比特率(bits/s)</td></tr><tr class="even"><td>-vframes number</td><td>设置转换多少帧(frame)的视频</td></tr><tr class="odd"><td>-r rate</td><td>帧速率(fps)（可以改，确认非标准桢率会导致音画不同步，所以只能设定为15或者29.97）</td></tr><tr class="even"><td>-s size</td><td>指定分辨率 (320x240)</td></tr><tr class="odd"><td>-aspect aspect</td><td>设置视频长宽比(4:3, 16:9 or 1.3333, 1.7777)</td></tr><tr class="even"><td>-croptop size</td><td>设置顶部切除尺寸(in pixels)</td></tr><tr class="odd"><td>-cropbottom size</td><td>设置底部切除尺寸(in pixels)</td></tr><tr class="even"><td>-cropleft size</td><td>设置左切除尺寸 (in pixels)</td></tr><tr class="odd"><td>-cropright size</td><td>设置右切除尺寸 (in pixels)</td></tr><tr class="even"><td>-padtop size</td><td>设置顶部补齐尺寸(in pixels)</td></tr><tr class="odd"><td>-padbottom size</td><td>底补齐(in pixels)</td></tr><tr class="even"><td>-padleft size</td><td>左补齐(in pixels)</td></tr><tr class="odd"><td>-padright size</td><td>右补齐(in pixels)</td></tr><tr class="even"><td>-padcolor color</td><td>补齐带颜色(000000-FFFFFF)</td></tr><tr class="odd"><td>-vn</td><td>取消视频</td></tr><tr class="even"><td>-vcodec codec</td><td>强制使用codec编解码方式('copy' to copy stream)</td></tr><tr class="odd"><td>-sameq</td><td>使用同样视频质量作为源（VBR）</td></tr><tr class="even"><td>-pass n</td><td>选择处理遍数（1或者2）。两遍编码非常有用。第一遍生成统计信息，第二遍生成精确的请求的码率</td></tr><tr class="odd"><td>-passlogfile file</td><td>选择两遍的纪录文件名为file</td></tr><tr class="even"><td>-newvideo</td><td>在现在的视频流后面加入新的视频流</td></tr><tr class="odd"><td>-vsync</td><td>The -vsync option has the following values:-1: auto (default) 0:passthrough 1: cfr (constant frame rate) 2: vfr (variable framerate)</td></tr><tr class="even"><td>-fps_mode</td><td>The -vsync option has the following values:-1: auto (default) 0:passthrough 1: cfr (constant frame rate) 2: vfr (variable framerate)</td></tr></tbody></table><table><thead><tr class="header"><th>高级视频选项</th><th></th></tr></thead><tbody><tr class="odd"><td>-pix_fmt format</td><td>set pixel format, 'list' as argument shows all the pixel formatssupported</td></tr><tr class="even"><td>-intra</td><td>仅适用帧内编码</td></tr><tr class="odd"><td>-qscale q</td><td>以<数值>质量为基础的VBR，取值0.01-255，约小质量越好</td></tr><tr class="even"><td>-loop_input</td><td>设置输入流的循环数(目前只对图像有效)</td></tr><tr class="odd"><td>-loop_output</td><td>设置输出视频的循环数，比如输出gif时设为0表示无限循环</td></tr><tr class="even"><td>-g int</td><td>设置图像组大小</td></tr><tr class="odd"><td>-cutoff int</td><td>设置截止频率</td></tr><tr class="even"><td>-qmin int</td><td>设定最小质量，与-qmax（设定最大质量）共用，比如-qmin 10 -qmax31</td></tr><tr class="odd"><td>-qmax int</td><td>设定最大质量</td></tr><tr class="even"><td>-qdiff int</td><td>量化标度间最大偏差 (VBR)</td></tr><tr class="odd"><td>-bf int</td><td>使用frames B 帧，支持mpeg1,mpeg2,mpeg4</td></tr></tbody></table><ol type="1"><li><h3id="切割视频可用于从四合一视频中快速分割出单视角视频">切割视频——可用于从四合一视频中快速分割出单视角视频</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg -i <span class="hljs-variable">$&#123;video_name&#125;</span>.mp4 -c hevc_nvenc -vf crop=1280:1280:0:2 -r 5 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_le.mp4<br></code></pre></td></tr></table></figure><ol type="1"><li><h3id="视频拼接可用于快速将单视角视频拼为41的视频">视频拼接——可用于快速将单视角视频拼为4*1的视频</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_fr.mp4 -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_le.mp4 -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_re.mp4 -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_ri.mp4 -filter_complex vstack=inputs=4 -c hevc_nvenc -b:v 3000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_4x1.mp4<br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="视频旋转">视频旋转</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg -i input.mp4 -c copy -metadata:s:v:0 rotate=90 output.mp4<br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="视频抽帧画质好">视频抽帧（画质好）</h3></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs COBOL">ffmpeg -i /data/video_1.mp4 -f image2  -vf fps=fps=1/60 -qscale:v 2 /data/mp4-%05d.jpeg<br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="视频抽帧画质差">视频抽帧（画质差）</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg -i inputfile.avi -r 1 -f image2 image-%05d.jpeg<br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="批量视频抽帧">批量视频抽帧</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-meta">#!/usr/bin/env bash</span><br> <br>videos_root=/data/videos<br>save_root=/data/video_imgs/Image_fps50/<br><span class="hljs-keyword">for</span> video <span class="hljs-keyword">in</span> <span class="hljs-variable">$videos_root</span>/*;<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$video</span><br>save_dir=$save_root$(<span class="hljs-built_in">basename</span> <span class="hljs-variable">$video</span> .avi)<br><span class="hljs-keyword">if</span> [ ! -d <span class="hljs-variable">$save_dir</span> ];<span class="hljs-keyword">then</span><br><span class="hljs-built_in">mkdir</span> <span class="hljs-variable">$save_dir</span><br><span class="hljs-keyword">fi</span><br>ffmpeg -i <span class="hljs-variable">$video</span> -f image2  -vf fps=fps=50 -qscale:v 2 <span class="hljs-variable">$save_dir</span>/mp4-%05d.jpeg<br> <br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="组合前面几个命令2-2视频转4-1视频">组合前面几个命令——2 *2视频转4 * 1视频</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Bash">video_name=<span class="hljs-variable">$1</span><br><span class="hljs-built_in">mkdir</span> results<br>ffmpeg -y -i <span class="hljs-variable">$&#123;video_name&#125;</span>.mp4 -c hevc_nvenc -vf crop=1920:1280:0:0 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_ri.mp4<br>ffmpeg -y -i <span class="hljs-variable">$&#123;video_name&#125;</span>.mp4 -c hevc_nvenc -vf crop=1920:1280:1920:0 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_le.mp4<br>ffmpeg -y -i <span class="hljs-variable">$&#123;video_name&#125;</span>.mp4 -c hevc_nvenc -vf crop=1920:1280:0:1280 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_fr.mp4<br>ffmpeg -y -i <span class="hljs-variable">$&#123;video_name&#125;</span>.mp4 -c hevc_nvenc -vf crop=1920:1280:1920:1280 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_re.mp4<br>ffmpeg -y -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_fr.mp4 -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_le.mp4 -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_re.mp4 -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_ri.mp4 -filter_complex vstack=inputs=4 -c hevc_nvenc -b:v 40000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_4x1.mp4<br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="按时间截取视频某一段">按时间截取视频某一段</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg  -i videodump_2023_02_21_15_49_26.mp4 -vcodec copy -acodec copy -ss 00:00:05 -to 00:00:25 ./out1.mp4 -y<br></code></pre></td></tr></table></figure><ol type="1"><li><h3id="四张单视角图片合并为一张4x1的图片">四张单视角图片合并为一张4x1的图片</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg -i front.png -i left.png -i rear.png -i right.png -filter_complex vstack=inputs=4 img1.png<br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="到41多个视频合并">2×2到4×1；多个视频合并</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment">##############################################################################################</span><br>视频信息：地址、后缀名、前后左右顺序、分辨率<br>root=/home/calmcar/wly/Hozon_ep40/54_white<br>suffix=.mp4<br>direct1=fr <span class="hljs-comment"># 左上</span><br>direct2=re <span class="hljs-comment"># 右上</span><br>direct3=le <span class="hljs-comment"># 左下</span><br>direct4=ri <span class="hljs-comment"># 右下</span><br>w=1280<br>h=960<br><span class="hljs-comment">##############################################################################################</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$&#123;root&#125;</span><br><span class="hljs-built_in">rm</span> videos.txt<br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> *<span class="hljs-variable">$&#123;suffix&#125;</span>;<span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;file &quot;</span><span class="hljs-variable">$&#123;name&#125;</span><span class="hljs-string">&quot;&quot;</span>&gt;&gt;videos.txt;<span class="hljs-keyword">done</span><br>ffmpeg -f concat -safe 0 -i videos.txt -c copy concat<span class="hljs-variable">$&#123;suffix&#125;</span><br><span class="hljs-comment">##############################################################################################</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3id="要在ffmpeg中使用多个显卡进行视频处理你可以使用ffmpeg的-hwaccel选项和-cv选项">要在FFmpeg中使用多个显卡进行视频处理，你可以使用FFmpeg的<code>-hwaccel</code>选项和<code>-c:v</code>选项。</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg -hwaccel_device 0,1 -hwaccel cuda -i input.mp4 -c:v h264_nvenc -gpu 0,1 output.mp4<br></code></pre></td></tr></table></figure><p>案例：2x2--&gt;4x1；多个视频合并成一个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 视频信息：地址、后缀名、前后左右顺序、分辨率</span><br>root=/home/calmcar/wly/Hozon_ep40/54_white <span class="hljs-comment"># 多个视频存放的目录</span><br>suffix=.mp4 <span class="hljs-comment"># 后缀</span><br>direct1=fr <span class="hljs-comment"># 左上</span><br>direct2=re <span class="hljs-comment"># 右上</span><br>direct3=le <span class="hljs-comment"># 左下</span><br>direct4=ri <span class="hljs-comment"># 右下</span><br>w=1280<br>h=960<br><span class="hljs-comment"># 合并视频</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$&#123;root&#125;</span><br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> *<span class="hljs-variable">$&#123;suffix&#125;</span>;<span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;file &quot;</span><span class="hljs-variable">$&#123;name&#125;</span><span class="hljs-string">&quot;&quot;</span> &gt;&gt; videos.txt;<span class="hljs-keyword">done</span><br>ffmpeg -f concat -safe 0 -i videos.txt -c copy concat<span class="hljs-variable">$&#123;suffix&#125;</span><br><span class="hljs-comment"># 2x2--&gt;4x1</span><br><span class="hljs-built_in">mkdir</span> results<br>video_name=concat<br>ffmpeg -i <span class="hljs-variable">$&#123;video_name&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span> -vf crop=<span class="hljs-variable">$w</span>:<span class="hljs-variable">$h</span>:0:0 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_<span class="hljs-variable">$&#123;direct1&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span><br>ffmpeg -i <span class="hljs-variable">$&#123;video_name&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span> -vf crop=<span class="hljs-variable">$w</span>:<span class="hljs-variable">$h</span>:<span class="hljs-variable">$w</span>:0 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_<span class="hljs-variable">$&#123;direct2&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span><br>ffmpeg -i <span class="hljs-variable">$&#123;video_name&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span> -vf crop=<span class="hljs-variable">$w</span>:<span class="hljs-variable">$h</span>:0:<span class="hljs-variable">$h</span> -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_<span class="hljs-variable">$&#123;direct3&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span><br>ffmpeg -i <span class="hljs-variable">$&#123;video_name&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span> -vf crop=<span class="hljs-variable">$w</span>:<span class="hljs-variable">$h</span>:<span class="hljs-variable">$w</span>:<span class="hljs-variable">$h</span> -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_<span class="hljs-variable">$&#123;direct4&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span><br>ffmpeg -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_fr<span class="hljs-variable">$&#123;suffix&#125;</span> -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_le<span class="hljs-variable">$&#123;suffix&#125;</span> -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_re<span class="hljs-variable">$&#123;suffix&#125;</span> -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_ri<span class="hljs-variable">$&#123;suffix&#125;</span> -filter_complex vstack=inputs=4 -b:v 3000k <span class="hljs-variable">$&#123;video_name&#125;</span>4<span class="hljs-variable">$&#123;suffix&#125;</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h2 id="图片筛选时的一些便捷操作">图片筛选时的一些便捷操作</h2></li><li><h3id="当我们有一堆单视角图片以前视角为准删除了相似帧图片后希望将保留下来的同帧号左右后视角图片取出时可以这么干">当我们有一堆单视角图片，以前视角为准删除了相似帧图片后，希望将保留下来的同帧号左右后视角图片取出时，可以这么干</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 首先新建四个文件夹，用于保存各视角图片</span><br><span class="hljs-built_in">mkdir</span> fr<br><span class="hljs-built_in">mkdir</span> le<br><span class="hljs-built_in">mkdir</span> re<br><span class="hljs-built_in">mkdir</span> ri<br><span class="hljs-comment"># 首先通过文件名，将四个视角的图片分别保存至四视角文件夹</span><br><span class="hljs-built_in">mv</span> *_fr_* ./fr<br><span class="hljs-built_in">mv</span> *_le_* ./le<br><span class="hljs-built_in">mv</span> *_re_* ./re<br><span class="hljs-built_in">mv</span> *_ri_* ./ri<br><span class="hljs-comment"># 之后我们以前视角作为基准，找出其他文件夹中包含同视频编号、md5值和帧号的图片</span><br><span class="hljs-built_in">cd</span> fr <br><span class="hljs-built_in">ls</span> * &gt; ../fr.txt<br><span class="hljs-built_in">cd</span> ..<br><span class="hljs-comment"># 此时我们主目录中除保存四视角图片文件夹外，还有一个fr.txt中保存有所有前视角图片名</span><br><span class="hljs-comment"># 之后我们要对fr.txt做一些操作</span><br>vim fr.txt<br><span class="hljs-comment"># 在vim界面中输入</span><br>:%s/_fr_/_le_/g <span class="hljs-comment"># 这个命令表示将所有_fr_替换为_le_</span><br>:x <span class="hljs-comment"># 保存退出</span><br><span class="hljs-comment"># 之后在终端输入</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `<span class="hljs-built_in">cat</span> fr.txt`;<span class="hljs-keyword">do</span> <span class="hljs-built_in">mv</span> le/<span class="hljs-variable">$&#123;i&#125;</span> ./;<span class="hljs-keyword">done</span>;<br><span class="hljs-comment"># 这样操作就可以把左视角与前视角文件夹的交集图片取出</span><br><span class="hljs-comment"># 同样对右、后文件夹操作</span><br>vim fr.txt<br><span class="hljs-comment"># 在vim界面中输入</span><br>:%s/_le_/_re_/g <span class="hljs-comment"># 这个命令表示将所有_fr_替换为_le_</span><br>:x <span class="hljs-comment"># 保存退出</span><br><span class="hljs-comment"># 之后在终端输入</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `<span class="hljs-built_in">cat</span> fr.txt`;<span class="hljs-keyword">do</span> <span class="hljs-built_in">mv</span> re/<span class="hljs-variable">$&#123;i&#125;</span> ./;<span class="hljs-keyword">done</span>;<br>vim fr.txt<br><span class="hljs-comment"># 在vim界面中输入</span><br>:%s/_re_/_ri_/g <span class="hljs-comment"># 这个命令表示将所有_fr_替换为_le_</span><br>:x <span class="hljs-comment"># 保存退出</span><br><span class="hljs-comment"># 之后在终端输入</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `<span class="hljs-built_in">cat</span> fr.txt`;<span class="hljs-keyword">do</span> <span class="hljs-built_in">mv</span> ri/<span class="hljs-variable">$&#123;i&#125;</span> ./;<span class="hljs-keyword">done</span>;<br><span class="hljs-comment"># 最后将前视角文件夹中图片取出，删除四文件夹和fr.txt即可</span><br><span class="hljs-built_in">mv</span> ./fr/* ./<br><span class="hljs-built_in">rm</span> -r fr/ re/ ri/ le/ fr.txt<br></code></pre></td></tr></table></figure><ol type="1"><li><h3id="遍历文件夹中所有文件不带后缀">遍历文件夹中所有文件（不带后缀）</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">basename</span> --suffix=.png -- *.png<br></code></pre></td></tr></table></figure><ol type="1"><li><h2 id="git-操作">Git 操作</h2></li><li><h3 id="git-强制回退删除已提交慎用">git强制回退，删除已提交（<strong><em>慎用</em></strong>）</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git reset --hard commit_id<br>git push --force origin 3dod<br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git-本地仓库关联远程仓库">git 本地仓库关联远程仓库</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git remote <span class="hljs-comment"># 查看当前有哪些远程仓库</span><br>git remote -v <span class="hljs-comment"># 列出当前仓库中已配置的远程仓库，并显示它们的 URL</span><br>git remote add &lt;本地仓库名&gt; &lt;远程仓库url&gt;  <span class="hljs-comment"># 本地仓库关联远程仓库</span><br>git remote <span class="hljs-built_in">rm</span>  &lt;远程仓库别名&gt;  <span class="hljs-comment"># 删除远程仓库</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git分支操作">Git分支操作</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git branch                  <span class="hljs-comment"># 查看分支</span><br>git branch  (branchname)     <span class="hljs-comment"># 创建新分支(branchname) </span><br>git checkout -b (branchname) <span class="hljs-comment"># 创建新分支并(branchname) 立即切换到该分支</span><br>git checkout (branchname)   <span class="hljs-comment"># 可以切换到分支(branchname) </span><br>git branch -d (branchname)  <span class="hljs-comment"># 可以删除分支(branchname) </span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git-本地仓库添加暂存文件">Git 本地仓库添加暂存文件</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git add &lt;文件1&gt; &lt;文件1&gt; &lt;文件2&gt; &lt;文件3&gt; ...<br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git-命令来查看相关文件的状态查看更新的详细信息">Git命令来查看相关文件的状态/查看更新的详细信息</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git status   <span class="hljs-comment"># 查看相关文件的状态</span><br>git diff     <span class="hljs-comment"># 查看尚未缓存的改动更新的详细信息</span><br>git diff --cached  <span class="hljs-comment"># 查看已缓存的改动： </span><br>git diff HEAD      <span class="hljs-comment"># 查看已缓存的与未缓存的所有改动：</span><br>git diff --<span class="hljs-built_in">stat</span>    <span class="hljs-comment"># 显示摘要而非整个 diff</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git-取消已缓存的内容">Git 取消已缓存的内容</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git reset HEAD test.txt   <span class="hljs-comment"># 用于取消已缓存的内容，如我们要取消已提交的test.txt文件.执行完之后，再使用commit提交时，test.txt文件不会被提交。</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git-提交暂存文件">Git 提交暂存文件</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git commit -m <span class="hljs-string">&quot;&lt;提交说明&gt;&quot;</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git-提交修改到远程仓库">Git 提交修改到远程仓库</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git push &lt;本地仓库名&gt; &lt;远程分支名&gt;<br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git-拉取远程仓库">git 拉取远程仓库</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git pull  <span class="hljs-comment">#相当于是从远程获取最新版本并merge到本地</span><br>git fetch  <span class="hljs-comment"># 相当于是从远程获取最新版本到本地，不会自动合并。</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git合并操作">Git合并操作</h3></li></ol><p>合并的时候，最大的难点就是冲突了，合并并不仅仅是简单的文件添加、移除的操作，Git也会合并修改，如果我们在两个分支中同时修改了同一个文件，这时再合并，就可能会产生冲突，冲突并不可怕，可怕的是要怎样去解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git merge branchname <span class="hljs-comment">#将任意分支合并到到当前分支中</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git查看提交历史">Git查看提交历史</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git <span class="hljs-built_in">log</span> <span class="hljs-comment"># 命令查看</span><br>git –oneline <span class="hljs-comment"># 查看历史记录的简洁版本</span><br>git –graph <span class="hljs-comment"># 查看历史中什么时候出现了分支、合并</span><br>git –reverse <span class="hljs-comment"># 逆向显示所有日志</span><br>git –author <span class="hljs-comment"># 查找指定用户的提交日志</span><br>git –since、–before、 --<span class="hljs-keyword">until</span>、–after <span class="hljs-comment"># 指定筛选日期</span><br>git –no-merges <span class="hljs-comment"># 选项以隐藏合并提交</span><br>git <span class="hljs-built_in">log</span> --autho <span class="hljs-comment"># 查找指定用户的提交日志</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git-标签操作">Git 标签操作</h3></li></ol><p>使用标签可以很方便的永远的记住那个特别的提交快照，比如：我们发一个新的版本时，可以给它加一个“vx.x”版本，这样你可以使用gittag给它打上标签。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git tag -a v1.0 <span class="hljs-comment"># 创建一个带注解的标签,可以很方便的永远的记住那个特别的提交快照</span><br>git tag <span class="hljs-comment"># 查看标签</span><br>git tag -a &lt;tagname&gt; -m <span class="hljs-string">&quot;某某标签&quot;</span> <span class="hljs-comment">#指定标签信息</span><br>git tag -a v1.0 d6f7147 <span class="hljs-comment"># d6f7147提交已发布，可对其追加标签 </span><br>git checkout tag_name <span class="hljs-comment"># 但是，这时候 git 可能会提示你当前处于一个“detached HEAD&quot; 状态。因为 tag 相当于是一个快照，是不能更改它的代码的。如果要在 tag 代码的基础上做修改，你需要一个分支： git checkout -b branch_name tag_name</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3id="配置.gitignore文件"><code>配置.gitignore</code>文件</h3></li></ol><p>把要忽略的文件名填进去，Git就会自动忽略这些文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 忽略所有.开头的隐藏文件:</span><br>.*<br><span class="hljs-comment"># 忽略所有.class文件:</span><br>*.class<br><br><span class="hljs-comment"># 排除忽略.gitignore和App.class:</span><br>!.gitignore<br>!App.class<br></code></pre></td></tr></table></figure><ol type="1"><li><h2 id="一些有用的小工具">一些有用的小工具</h2></li><li><h3 id="pigz多线程压缩">pigz多线程压缩</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-get install -y pigz<br>tar cv filename | pigz -9 -p16 -k &gt; filename.tar.gz<br><span class="hljs-comment"># -9 为压缩级别 -p16为调用线程数量 -k为保留源文件</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="多线程apt-fast">多线程apt-fast</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-add-repository ppa:apt-fast/stable<br>sudo apt-get install apt-fast<br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="conda环境迁移">conda环境迁移</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">conda install conda-pack conda-pack<br>conda pack -p /path/to/env -o env_name.tar.gz<br>tar zxcf env_name.tar.gz -C env_name<br><span class="hljs-built_in">source</span> env_name/bin/activate<br>conda un<br></code></pre></td></tr></table></figure><ol type="1"><li><h2 id="shell网络命令">shell网络命令</h2></li><li><h3id="ssh进行远程登录和执行命令">ssh进行远程登录和执行命令</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ssh user@host  <span class="hljs-comment"># user是要登录的用户名，host是要登录的主机名或IP地址</span><br>ssh -L 8080:localhost:80 user@example.com <span class="hljs-comment"># 创建一个SSH隧道，将本地端口8080转发到远程主机http://example.com的80端口</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="使用scp进行文件传输">使用scp进行文件传输</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">scp root@192.168.0.101:/var/www/test.txt /var/www/local_dir（本地目录） <span class="hljs-comment"># scp root@192.168.0.101:/var/www/test.txt 把192.168.0.101上的/var/www/test.txt 的文件下载到/var/www/local_dir（本地目录）</span><br>scp -r root@192.168.0.101:/var/www/test（远程目录）   /var/www/（本地目录）<br>scp example.txt user@example.com:/home/user <span class="hljs-comment"># 将本地文件example.txt传输到远程主机http://example.com的/home/user目录下</span><br>scp -r <span class="hljs-built_in">test</span> （本地目录） root@192.168.0.101:/var/www/（远程目录） <span class="hljs-comment"># 把当前目录下的test目录上传到服务器的/var/www/ 目录</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ffmpeg</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
