<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于车道线的道路标定</title>
    <link href="/2023/12/26/%E5%9F%BA%E4%BA%8E%E8%BD%A6%E9%81%93%E7%BA%BF%E7%9A%84%E9%81%93%E8%B7%AF%E6%A0%87%E5%AE%9A/"/>
    <url>/2023/12/26/%E5%9F%BA%E4%BA%8E%E8%BD%A6%E9%81%93%E7%BA%BF%E7%9A%84%E9%81%93%E8%B7%AF%E6%A0%87%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="基于车道线的Cam2vehicle道路标定"><a href="#基于车道线的Cam2vehicle道路标定" class="headerlink" title="基于车道线的Cam2vehicle道路标定"></a>基于车道线的Cam2vehicle道路标定</h1><p>1.pitch角的标定：基于假设，车道线线平行，车体和路面平行（车子没有抖动），车道线像素投影到地面为平行的3D点。</p><ul><li><em>怎么判断车子当前是平稳的状态？</em></li></ul><p>优化标量：pitch</p><p>目标函数：车道线地面投影3D点平行。（车道线地面投影的夹角。优化目标夹角为0）</p><p><strong>优化</strong>过程：修改pitch-&gt;R矩阵-&gt;引入鱼眼原图-&gt;3D-&gt;平行判断</p><p>2.roll角度：车道线等宽、灯杆垂直地面\（或者有第三方车道线真值提供）；</p><ul><li><em>怎么准确检测车道线的边缘</em></li><li><em>怎么检测灯杆轴线</em></li></ul><p>3.yaw:多帧判断车子直行，计算车道线投影点和X方向夹角</p><p>多帧<strong>优化</strong>yaw角，使得所有点在一条直线上；</p><p>通过标志牌测距，优化yaw角，结合单目中用内参计算标志牌的距离。结合里程计，标志牌在的x方向的位移等于行进里程。</p><ul><li><em>怎么结合单目中用内参计算标志牌的距离</em></li></ul><p>参考</p><p><a href="https://cloud.tencent.com/developer/article/1673568">算法集锦（18） | 自动驾驶 | 车道线检测算法-腾讯云开发者社区-腾讯云 (tencent.com)</a>                                                                                    </p><p> 在HSV空间隔离车道线，效果很糟糕，白色车道线和灰暗地面无法分辨、</p><p><img src="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20231226193154167.png" alt="使用HSV隔离车道线"></p>]]></content>
    
    
    <categories>
      
      <category>自动驾驶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>在线标定</tag>
      
      <tag>环视相机</tag>
      
      <tag>车道线检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git CI/CD搭建自动化编译</title>
    <link href="/2023/12/18/Git-CI-CD%E6%90%AD%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E5%B9%B3%E5%8F%B0/"/>
    <url>/2023/12/18/Git-CI-CD%E6%90%AD%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在大型的开源项目或者软件开发过程中， 很多开发者都会去提交<code>PR</code>或者进行代码的 <code>push</code>操作。如果对于每次代码合并都需要项目的核心维护者进行 <code>code review</code>，这项工作是及其困难而且耗时的。因此许多团队都会指定一套代码规范, 然后编写测试用例严格的检查每次代码修改， 这样能够非常有效的减少后期代码维护的成本。</p><p>现在，基于<strong>githubaction</strong>, 我们可以自动化的完成代码的 <code>CI/CD</code> 工作流。­<strong>Githubaction</strong>是 GitHub 推出的持续集成 (Con­tin­u­ous in­te­gra­tion，简称 CI) 服务，它提供了配置非常不错的虚拟服务器环境，基于它可以进行构建、测试、打包、部署项目。</p><p>Github Actions 的最大优势就是它是与 GitHub 高度整合的，只需一个配置文件即可自动开启服务。甚至你不需要购买服务器 —— GitHub Actions 自带云环境运行，包括私有仓库也可以享用，而且云环境性能也非常不错。</p><p>本篇文章将介绍 GitHub Ac­tions 的基本使用方法。</p><h3 id="CI-Continuous-integration"><a href="#CI-Continuous-integration" class="headerlink" title="CI (Continuous integration)"></a>CI (Continuous integration)</h3><p>互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration，简称CI）</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>持续集成指的是，频繁地（一天多次）将代码集成到主干。 它的好处主要有两个</p><ul><li>快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。</li><li>防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。</li></ul><p>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p><h4 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h4><p>持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。 持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。</p><h4 id="持续部署"><a href="#持续部署" class="headerlink" title="持续部署"></a>持续部署</h4><p>持续部署（continuous deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。</p><p>持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>根据持续集成的设计，代码从提交到生产，整个过程有以下几步。</p><p>（1）提交</p><p>流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交（commit）。</p><p>（2）测试（第一轮）</p><p>代码仓库对commit操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。 测试有好几种。</p><ul><li>单元测试：针对函数或模块的测试</li><li>集成测试：针对整体产品的某个功能的测试，又称功能测试</li><li>端对端测试：从用户界面直达数据库的全链路测试</li></ul><p>(3) 构建</p><p>通过第一轮测试，代码就可以合并进主干，就算可以交付了。 交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。 常用的构建工具如下。</p><ul><li>Jenkins</li><li>Travis</li><li>Codeship</li><li>Strider</li></ul><p>(4) 测试（第二轮）</p><p>构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。</p><p>第二轮是全面测试，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。</p><p>需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。</p><p>(5) 部署</p><p>通过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。</p><p>(6) 回滚</p><p>一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>项目工程管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用Git操作</title>
    <link href="/2023/12/18/%E5%B8%B8%E7%94%A8Git%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/12/18/%E5%B8%B8%E7%94%A8Git%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="常用Git-操作"><a href="#常用Git-操作" class="headerlink" title="常用Git 操作"></a>常用Git 操作</h2><h3 id="1-git-强制回退，删除已提交（慎用）"><a href="#1-git-强制回退，删除已提交（慎用）" class="headerlink" title="1.git 强制回退，删除已提交（慎用）"></a>1.git 强制回退，删除已提交（<em><strong>慎用</strong></em>）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git reset --hard commit_id<br>git push --force origin 3dod<br></code></pre></td></tr></table></figure><h3 id="2-git-本地仓库关联远程仓库"><a href="#2-git-本地仓库关联远程仓库" class="headerlink" title="2.git 本地仓库关联远程仓库"></a>2.git 本地仓库关联远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git remote <span class="hljs-comment"># 查看当前有哪些远程仓库</span><br>git remote -v <span class="hljs-comment"># 列出当前仓库中已配置的远程仓库，并显示它们的 URL</span><br>git remote add &lt;本地仓库名&gt; &lt;远程仓库url&gt;  <span class="hljs-comment"># 本地仓库关联远程仓库</span><br>git remote <span class="hljs-built_in">rm</span>  &lt;远程仓库别名&gt;  <span class="hljs-comment"># 删除远程仓库</span><br></code></pre></td></tr></table></figure><h3 id="3-Git分支操作"><a href="#3-Git分支操作" class="headerlink" title="3.Git分支操作"></a>3.Git分支操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git branch                  <span class="hljs-comment"># 查看分支</span><br>git branch  (branchname)     <span class="hljs-comment"># 创建新分支(branchname) </span><br>git checkout -b (branchname) <span class="hljs-comment"># 创建新分支并(branchname) 立即切换到该分支</span><br>git checkout (branchname)   <span class="hljs-comment"># 可以切换到分支(branchname) </span><br>git branch -d (branchname)  <span class="hljs-comment"># 可以删除分支(branchname) </span><br></code></pre></td></tr></table></figure><h3 id="4-Git-本地仓库添加暂存文件"><a href="#4-Git-本地仓库添加暂存文件" class="headerlink" title="4.Git 本地仓库添加暂存文件"></a>4.Git 本地仓库添加暂存文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git add &lt;文件1&gt; &lt;文件1&gt; &lt;文件2&gt; &lt;文件3&gt; ...<br></code></pre></td></tr></table></figure><h3 id="5-Git-命令来查看相关文件的状态-查看更新的详细信息"><a href="#5-Git-命令来查看相关文件的状态-查看更新的详细信息" class="headerlink" title="5.Git 命令来查看相关文件的状态&#x2F;查看更新的详细信息"></a>5.Git 命令来查看相关文件的状态&#x2F;查看更新的详细信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git status   <span class="hljs-comment"># 查看相关文件的状态</span><br>git diff     <span class="hljs-comment"># 查看尚未缓存的改动更新的详细信息</span><br>git diff --cached  <span class="hljs-comment"># 查看已缓存的改动： </span><br>git diff HEAD      <span class="hljs-comment"># 查看已缓存的与未缓存的所有改动：</span><br>git diff --<span class="hljs-built_in">stat</span>    <span class="hljs-comment"># 显示摘要而非整个 diff</span><br></code></pre></td></tr></table></figure><h3 id="6-Git-取消已缓存的内容"><a href="#6-Git-取消已缓存的内容" class="headerlink" title="6.Git 取消已缓存的内容"></a>6.Git 取消已缓存的内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git reset HEAD test.txt   <span class="hljs-comment"># 用于取消已缓存的内容，如我们要取消已提交的test.txt文件.执行完之后，再使用commit提交时，test.txt文件不会被提交。</span><br></code></pre></td></tr></table></figure><h3 id="7-Git-提交暂存文件"><a href="#7-Git-提交暂存文件" class="headerlink" title="7.Git 提交暂存文件"></a>7.Git 提交暂存文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git commit -m <span class="hljs-string">&quot;&lt;提交说明&gt;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="8-Git-提交修改到远程仓库"><a href="#8-Git-提交修改到远程仓库" class="headerlink" title="8.Git 提交修改到远程仓库"></a>8.Git 提交修改到远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git push &lt;本地仓库名&gt; &lt;远程分支名&gt;<br></code></pre></td></tr></table></figure><h3 id="9-Git-拉取远程仓库"><a href="#9-Git-拉取远程仓库" class="headerlink" title="9.Git 拉取远程仓库"></a>9.Git 拉取远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git pull  <span class="hljs-comment">#相当于是从远程获取最新版本并merge到本地</span><br>git fetch  <span class="hljs-comment"># 相当于是从远程获取最新版本到本地，不会自动合并。</span><br></code></pre></td></tr></table></figure><h3 id="10-Git合并操作"><a href="#10-Git合并操作" class="headerlink" title="10.Git合并操作"></a>10.Git合并操作</h3><p>合并的时候，最大的难点就是冲突了，合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改，如果我们在两个分支中同时修改了同一个文件，这时再合并，就可能会产生冲突，冲突并不可怕，可怕的是要怎样去解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git merge branchname <span class="hljs-comment">#将任意分支合并到到当前分支中</span><br></code></pre></td></tr></table></figure><h3 id="11-Git查看提交历史"><a href="#11-Git查看提交历史" class="headerlink" title="11.Git查看提交历史"></a>11.Git查看提交历史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git <span class="hljs-built_in">log</span> <span class="hljs-comment"># 命令查看</span><br>git –oneline <span class="hljs-comment"># 查看历史记录的简洁版本</span><br>git –graph <span class="hljs-comment"># 查看历史中什么时候出现了分支、合并</span><br>git –reverse <span class="hljs-comment"># 逆向显示所有日志</span><br>git –author <span class="hljs-comment"># 查找指定用户的提交日志</span><br>git –since、–before、 --<span class="hljs-keyword">until</span>、–after <span class="hljs-comment"># 指定筛选日期</span><br>git –no-merges <span class="hljs-comment"># 选项以隐藏合并提交</span><br>git <span class="hljs-built_in">log</span> --autho <span class="hljs-comment"># 查找指定用户的提交日志</span><br></code></pre></td></tr></table></figure><h3 id="12-Git-标签操作"><a href="#12-Git-标签操作" class="headerlink" title="12.Git 标签操作"></a>12.Git 标签操作</h3><p>使用标签可以很方便的永远的记住那个特别的提交快照，比如：我们发一个新的版本时，可以给它加一个“vx.x”版本，这样你可以使用git tag给它打上标签。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git tag -a v1.0 <span class="hljs-comment"># 创建一个带注解的标签,可以很方便的永远的记住那个特别的提交快照</span><br>git tag <span class="hljs-comment"># 查看标签</span><br>git tag -a &lt;tagname&gt; -m <span class="hljs-string">&quot;某某标签&quot;</span> <span class="hljs-comment">#指定标签信息</span><br>git tag -a v1.0 d6f7147 <span class="hljs-comment"># d6f7147提交已发布，可对其追加标签 </span><br>git checkout tag_name <span class="hljs-comment"># 但是，这时候 git 可能会提示你当前处于一个“detached HEAD&quot; 状态。因为 tag 相当于是一个快照，是不能更改它的代码的。如果要在 tag 代码的基础上做修改，你需要一个分支： git checkout -b branch_name tag_name</span><br></code></pre></td></tr></table></figure><h3 id="13-配置-gitignore文件"><a href="#13-配置-gitignore文件" class="headerlink" title="13.配置.gitignore文件"></a>13.<code>配置.gitignore</code>文件</h3><p>把要忽略的文件名填进去，Git就会自动忽略这些文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 忽略所有.开头的隐藏文件:</span><br>.*<br><span class="hljs-comment"># 忽略所有.class文件:</span><br>*.class<br><br><span class="hljs-comment"># 排除忽略.gitignore和App.class:</span><br>!.gitignore<br>!App.class<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>项目工程管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更有效的更积极的工作生活</title>
    <link href="/2023/12/18/%E6%9B%B4%E6%9C%89%E6%95%88%E7%9A%84%E6%9B%B4%E7%A7%AF%E6%9E%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%94%9F%E6%B4%BB/"/>
    <url>/2023/12/18/%E6%9B%B4%E6%9C%89%E6%95%88%E7%9A%84%E6%9B%B4%E7%A7%AF%E6%9E%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%94%9F%E6%B4%BB/</url>
    
    <content type="html"><![CDATA[<p>更有效的更积极的工作生活</p><p>《孟子.滕文公章句上》中提到”劳心者治人，劳力者治于人；治于 人者食人，治人者食于人；天下之通义也。“</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安装paddle-gpu后找不到动态链接库libcuda.so</title>
    <link href="/2023/12/10/%E5%AE%89%E8%A3%85paddle-gpu%E5%90%8E%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93libcuda-so/"/>
    <url>/2023/12/10/%E5%AE%89%E8%A3%85paddle-gpu%E5%90%8E%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93libcuda-so/</url>
    
    <content type="html"><![CDATA[<h1 id="安装paddle-gpu后找不到动态链接库libcuda-so"><a href="#安装paddle-gpu后找不到动态链接库libcuda-so" class="headerlink" title="安装paddle-gpu后找不到动态链接库libcuda.so"></a>安装<strong>paddle-gpu</strong>后找不到动态链接库libcuda.so</h1><p>按照文档安装<strong>paddle-gpu</strong>后，<strong>paddle-gpu</strong>不能正常运行，并报错。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import paddle</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; paddle.utils.run_check()</span><br>Running verify PaddlePaddle program ...<br>I1209 22:43:10.566331  2436 interpretercore.cc:237] New Executor is Running.<br>W1209 22:43:10.566608  2436 gpu_resources.cc:119] Please NOTE: device: 0, GPU Compute Capability: 8.6, Driver API Version: 12.0, Runtime API Version: 11.8<br>W1209 22:43:10.585208  2436 gpu_resources.cc:149] device: 0, cuDNN Version: 8.6.<br>W1209 22:43:12.852262  2436 dynamic_loader.cc:303] The third-party dynamic library (libcuda.so) that Paddle depends on is not configured correctly. (error code is libcuda.so: cannot open shared object file: No such file or directory)<br>  Suggestions:<br>  1. Check if the third-party dynamic library (e.g. CUDA, CUDNN) is installed correctly and its version is matched with paddlepaddle you installed.<br>  2. Configure third-party dynamic library environment variables as follows:<br>  - Linux: set LD_LIBRARY_PATH by `export LD_LIBRARY_PATH=...`<br>  - Windows: set PATH by `set PATH=XXX;<br><br></code></pre></td></tr></table></figure><ul><li>首先从log 的提示中，可以看出是无法链接到<strong>libcuda.so</strong> 文件，先查找<strong>libcuda.so</strong> 文件的位置。作为动态链接库一般都安装在<code>/usr/</code>文件夹下。在<code>/usr/</code>文件夹下查找<strong>libcuda.so</strong> 文件,其路径为<code>/usr/lib/wsl/lib/libcuda.so</code>。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">user@unutu:sudo find /usr/ -name &quot;libcuda.so&quot;<br>/usr/lib/wsl/lib/libcuda.so<br></code></pre></td></tr></table></figure><p>在这里补充一下，我是在conda 的子环境<strong>env_paddle</strong>中安装了paddle-gpu。因此需要将子环境<strong>env_paddle</strong>的库路径 <code>～/miniconda3/envs/env_paddle/lib/</code> 在 <code>～/.bashrc</code> 中加入到环境变量，使用指令<code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:~/miniconda3/envs/env_paddle/lib/</code>。</p><ul><li>然后在环境变量下创建软连接，具体用法是：<code>ln -s  [源文件]  [软链接文件]</code>。这样paddle就能在环境变量下链接到到<strong>libcuda.so</strong>文件。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s  /usr/lib/wsl/lib/libcuda.so  ~/miniconda3/envs/env_paddle/lib/libcuda.so<br></code></pre></td></tr></table></figure><ul><li>在shell中输入 <code>python -c &quot;import paddle; paddle.utils.run_check()&quot;</code>，提示<code>PaddlePaddle is installed successfully! </code>。则问题已解决。</li></ul>]]></content>
    
    
    <categories>
      
      <category>日常部署排故</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>paddle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在线标定_前后帧三角测量</title>
    <link href="/2023/12/06/%E5%9C%A8%E7%BA%BF%E6%A0%87%E5%AE%9A-%E5%89%8D%E5%90%8E%E5%B8%A7%E4%B8%89%E8%A7%92%E6%B5%8B%E9%87%8F/"/>
    <url>/2023/12/06/%E5%9C%A8%E7%BA%BF%E6%A0%87%E5%AE%9A-%E5%89%8D%E5%90%8E%E5%B8%A7%E4%B8%89%E8%A7%92%E6%B5%8B%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>sdasadsad</p>]]></content>
    
    
    <categories>
      
      <category>自动驾驶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>在线标定</tag>
      
      <tag>环视相机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo+github+windows搭建个人博客</title>
    <link href="/2023/12/06/hexo-github-windows%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/12/06/hexo-github-windows%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo-github-windows搭建个人博客"><a href="#hexo-github-windows搭建个人博客" class="headerlink" title="hexo+github+windows搭建个人博客"></a>hexo+github+windows搭建个人博客</h1><p>对于搭载免费的静态网页，gitee是个不错的选择。但由于gitee需要实名备案，最终选择github来搭载个人博客的静态网页。但github上的page只支持public仓库，且支持为一个静态网页I&#x2F;O，且静态网页仓库名必须命名为<em><strong>用户名</strong></em>.github.io。而且通过page功能发布的网页网址定义为https:&#x2F;&#x2F;<em><strong>用户名</strong></em>.github.io&#x2F;。</p><h3 id="第一步：GitHub-Page搭建"><a href="#第一步：GitHub-Page搭建" class="headerlink" title="第一步：GitHub Page搭建"></a>第一步：GitHub Page搭建</h3><p>1、在Github新建一个仓库，命名为:<em><strong>用户名</strong></em>.github.io</p><p>2、 启用GitHub Page：</p><p>点击“Setting”菜单进入设置</p><p>首先点击”Launch automatic page generator”</p><h3 id="第二步：安装Hexo"><a href="#第二步：安装Hexo" class="headerlink" title="第二步：安装Hexo"></a>第二步：安装Hexo</h3><ol><li><p>安装npm</p></li><li><p>安装git</p></li><li><p>安装hexo</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bash大法好</title>
    <link href="/2023/12/04/Bash%E5%A4%A7%E6%B3%95%E5%A5%BD/"/>
    <url>/2023/12/04/Bash%E5%A4%A7%E6%B3%95%E5%A5%BD/</url>
    
    <content type="html"><![CDATA[<p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p><ol><li><h2 id="ffmpeg-处理视频文件的一些操作"><a href="#ffmpeg-处理视频文件的一些操作" class="headerlink" title="ffmpeg 处理视频文件的一些操作"></a>ffmpeg 处理视频文件的一些操作</h2></li></ol><p>在172.16.2.88服务器上，&#x2F;data01&#x2F;ffmpeg-n5.1-latest-linux64-lgpl-shared-5.1.tar.gz 是一个比较新的ffmpeg版本，该版本可以使用n卡做编解码器，也就是是-c hevc_nvenc参数加速处理。</p><p>该版本包含：(decoders: hevc hevc_qsv hevc_cuvid ) (encoders: hevc_amf hevc_nvenc hevc_qsv hevc_vaapi libkvazaar )，hevc_amf是amd集成显卡的编码器，hevc_qsv是intel集成显卡的编码器。</p><ol><li><h3 id="常用参数（来自网络）"><a href="#常用参数（来自网络）" class="headerlink" title="常用参数（来自网络）"></a>常用参数（来自网络）</h3></li></ol><table><thead><tr><th>基本选项:</th><th></th></tr></thead><tbody><tr><td>-formats</td><td>输出所有可用格式</td></tr><tr><td>-f fmt</td><td>指定格式(音频或视频格式)</td></tr><tr><td>-i filename</td><td>指定输入文件名，在linux下当然也能指定:0.0(屏幕录制)或摄像头</td></tr><tr><td>-y</td><td>覆盖已有文件</td></tr><tr><td>-t duration</td><td>记录时长为t</td></tr><tr><td>-fs limit_size</td><td>设置文件大小上限</td></tr><tr><td>-ss time_off</td><td>从指定的时间(s)开始， [-]hh:mm:ss[.xxx]的格式也支持</td></tr><tr><td>-itsoffset time_off</td><td>设置时间偏移(s)，该选项影响所有后面的输入文件。该偏移被加到输入文件的时戳，定义一个正偏移意味着相应的流被延迟了 offset秒。 [-]hh:mm:ss[.xxx]的格式也支持</td></tr><tr><td>-title string</td><td>标题</td></tr><tr><td>-timestamp time</td><td>时间戳</td></tr><tr><td>-author string</td><td>作者</td></tr><tr><td>-copyright string</td><td>版权信息</td></tr><tr><td>-comment string</td><td>评论</td></tr><tr><td>-album string</td><td>album名</td></tr><tr><td>-v verbose</td><td>与log相关的</td></tr><tr><td>-target type</td><td>设置目标文件类型(“vcd”, “svcd”, “dvd”, “dv”, “dv50”, “pal-vcd”, “ntsc-svcd”, …)</td></tr><tr><td>-dframes number</td><td>设置要记录的帧数</td></tr></tbody></table><table><thead><tr><th>视频选项:</th><th></th></tr></thead><tbody><tr><td>-b</td><td>指定比特率(bits&#x2F;s)，似乎ffmpeg是自动VBR的，指定了就大概是平均比特率</td></tr><tr><td>-bitexact</td><td>使用标准比特率</td></tr><tr><td>-vb</td><td>指定视频比特率(bits&#x2F;s)</td></tr><tr><td>-vframes number</td><td>设置转换多少帧(frame)的视频</td></tr><tr><td>-r rate</td><td>帧速率(fps) （可以改，确认非标准桢率会导致音画不同步，所以只能设定为15或者29.97）</td></tr><tr><td>-s size</td><td>指定分辨率 (320x240)</td></tr><tr><td>-aspect aspect</td><td>设置视频长宽比(4:3, 16:9 or 1.3333, 1.7777)</td></tr><tr><td>-croptop size</td><td>设置顶部切除尺寸(in pixels)</td></tr><tr><td>-cropbottom size</td><td>设置底部切除尺寸(in pixels)</td></tr><tr><td>-cropleft size</td><td>设置左切除尺寸 (in pixels)</td></tr><tr><td>-cropright size</td><td>设置右切除尺寸 (in pixels)</td></tr><tr><td>-padtop size</td><td>设置顶部补齐尺寸(in pixels)</td></tr><tr><td>-padbottom size</td><td>底补齐(in pixels)</td></tr><tr><td>-padleft size</td><td>左补齐(in pixels)</td></tr><tr><td>-padright size</td><td>右补齐(in pixels)</td></tr><tr><td>-padcolor color</td><td>补齐带颜色(000000-FFFFFF)</td></tr><tr><td>-vn</td><td>取消视频</td></tr><tr><td>-vcodec codec</td><td>强制使用codec编解码方式(‘copy’ to copy stream)</td></tr><tr><td>-sameq</td><td>使用同样视频质量作为源（VBR）</td></tr><tr><td>-pass n</td><td>选择处理遍数（1或者2）。两遍编码非常有用。第一遍生成统计信息，第二遍生成精确的请求的码率</td></tr><tr><td>-passlogfile file</td><td>选择两遍的纪录文件名为file</td></tr><tr><td>-newvideo</td><td>在现在的视频流后面加入新的视频流</td></tr><tr><td>-vsync</td><td>The -vsync option has the following values:-1: auto (default) 0: passthrough 1: cfr (constant frame rate) 2: vfr (variable frame rate)</td></tr><tr><td>-fps_mode</td><td>The -vsync option has the following values:-1: auto (default) 0: passthrough 1: cfr (constant frame rate) 2: vfr (variable frame rate)</td></tr></tbody></table><table><thead><tr><th>高级视频选项</th><th></th></tr></thead><tbody><tr><td>-pix_fmt format</td><td>set pixel format, ‘list’ as argument shows all the pixel formats supported</td></tr><tr><td>-intra</td><td>仅适用帧内编码</td></tr><tr><td>-qscale q</td><td>以&lt;数值&gt;质量为基础的VBR，取值0.01-255，约小质量越好</td></tr><tr><td>-loop_input</td><td>设置输入流的循环数(目前只对图像有效)</td></tr><tr><td>-loop_output</td><td>设置输出视频的循环数，比如输出gif时设为0表示无限循环</td></tr><tr><td>-g int</td><td>设置图像组大小</td></tr><tr><td>-cutoff int</td><td>设置截止频率</td></tr><tr><td>-qmin int</td><td>设定最小质量，与-qmax（设定最大质量）共用，比如-qmin 10 -qmax 31</td></tr><tr><td>-qmax int</td><td>设定最大质量</td></tr><tr><td>-qdiff int</td><td>量化标度间最大偏差 (VBR)</td></tr><tr><td>-bf int</td><td>使用frames B 帧，支持mpeg1,mpeg2,mpeg4</td></tr></tbody></table><ol><li><h3 id="切割视频——可用于从四合一视频中快速分割出单视角视频"><a href="#切割视频——可用于从四合一视频中快速分割出单视角视频" class="headerlink" title="切割视频——可用于从四合一视频中快速分割出单视角视频"></a>切割视频——可用于从四合一视频中快速分割出单视角视频</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg -i <span class="hljs-variable">$&#123;video_name&#125;</span>.mp4 -c hevc_nvenc -vf crop=1280:1280:0:2 -r 5 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_le.mp4<br></code></pre></td></tr></table></figure><ol><li><h3 id="视频拼接——可用于快速将单视角视频拼为4-1的视频"><a href="#视频拼接——可用于快速将单视角视频拼为4-1的视频" class="headerlink" title="视频拼接——可用于快速将单视角视频拼为4*1的视频"></a>视频拼接——可用于快速将单视角视频拼为4*1的视频</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_fr.mp4 -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_le.mp4 -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_re.mp4 -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_ri.mp4 -filter_complex vstack=inputs=4 -c hevc_nvenc -b:v 3000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_4x1.mp4<br></code></pre></td></tr></table></figure><ol><li><h3 id="视频旋转"><a href="#视频旋转" class="headerlink" title="视频旋转"></a>视频旋转</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg -i input.mp4 -c copy -metadata:s:v:0 rotate=90 output.mp4<br></code></pre></td></tr></table></figure><ol><li><h3 id="视频抽帧（画质好）"><a href="#视频抽帧（画质好）" class="headerlink" title="视频抽帧（画质好）"></a>视频抽帧（画质好）</h3></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs COBOL">ffmpeg -i /data/video_1.mp4 -f image2  -vf fps=fps=1/60 -qscale:v 2 /data/mp4-%05d.jpeg<br></code></pre></td></tr></table></figure><ol><li><h3 id="视频抽帧（画质差）"><a href="#视频抽帧（画质差）" class="headerlink" title="视频抽帧（画质差）"></a>视频抽帧（画质差）</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg -i inputfile.avi -r 1 -f image2 image-%05d.jpeg<br></code></pre></td></tr></table></figure><ol><li><h3 id="批量视频抽帧"><a href="#批量视频抽帧" class="headerlink" title="批量视频抽帧"></a>批量视频抽帧</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-meta">#!/usr/bin/env bash</span><br> <br>videos_root=/data/videos<br>save_root=/data/video_imgs/Image_fps50/<br><span class="hljs-keyword">for</span> video <span class="hljs-keyword">in</span> <span class="hljs-variable">$videos_root</span>/*;<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$video</span><br>save_dir=$save_root$(<span class="hljs-built_in">basename</span> <span class="hljs-variable">$video</span> .avi)<br><span class="hljs-keyword">if</span> [ ! -d <span class="hljs-variable">$save_dir</span> ];<span class="hljs-keyword">then</span><br><span class="hljs-built_in">mkdir</span> <span class="hljs-variable">$save_dir</span><br><span class="hljs-keyword">fi</span><br>ffmpeg -i <span class="hljs-variable">$video</span> -f image2  -vf fps=fps=50 -qscale:v 2 <span class="hljs-variable">$save_dir</span>/mp4-%05d.jpeg<br> <br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><ol><li><h3 id="组合前面几个命令——2-2视频转4-1视频"><a href="#组合前面几个命令——2-2视频转4-1视频" class="headerlink" title="组合前面几个命令——2 * 2视频转4 * 1视频"></a>组合前面几个命令——2 * 2视频转4 * 1视频</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Bash">video_name=<span class="hljs-variable">$1</span><br><span class="hljs-built_in">mkdir</span> results<br>ffmpeg -y -i <span class="hljs-variable">$&#123;video_name&#125;</span>.mp4 -c hevc_nvenc -vf crop=1920:1280:0:0 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_ri.mp4<br>ffmpeg -y -i <span class="hljs-variable">$&#123;video_name&#125;</span>.mp4 -c hevc_nvenc -vf crop=1920:1280:1920:0 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_le.mp4<br>ffmpeg -y -i <span class="hljs-variable">$&#123;video_name&#125;</span>.mp4 -c hevc_nvenc -vf crop=1920:1280:0:1280 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_fr.mp4<br>ffmpeg -y -i <span class="hljs-variable">$&#123;video_name&#125;</span>.mp4 -c hevc_nvenc -vf crop=1920:1280:1920:1280 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_re.mp4<br>ffmpeg -y -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_fr.mp4 -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_le.mp4 -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_re.mp4 -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_ri.mp4 -filter_complex vstack=inputs=4 -c hevc_nvenc -b:v 40000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_4x1.mp4<br></code></pre></td></tr></table></figure><ol><li><h3 id="按时间截取视频某一段"><a href="#按时间截取视频某一段" class="headerlink" title="按时间截取视频某一段"></a>按时间截取视频某一段</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg  -i videodump_2023_02_21_15_49_26.mp4 -vcodec copy -acodec copy -ss 00:00:05 -to 00:00:25 ./out1.mp4 -y<br></code></pre></td></tr></table></figure><ol><li><h3 id="四张单视角图片合并为一张4x1的图片"><a href="#四张单视角图片合并为一张4x1的图片" class="headerlink" title="四张单视角图片合并为一张4x1的图片"></a>四张单视角图片合并为一张4x1的图片</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg -i front.png -i left.png -i rear.png -i right.png -filter_complex vstack=inputs=4 img1.png<br></code></pre></td></tr></table></figure><ol><li><h3 id="2×2到4×1；多个视频合并"><a href="#2×2到4×1；多个视频合并" class="headerlink" title="2×2到4×1；多个视频合并"></a>2×2到4×1；多个视频合并</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment">##############################################################################################</span><br>视频信息：地址、后缀名、前后左右顺序、分辨率<br>root=/home/calmcar/wly/Hozon_ep40/54_white<br>suffix=.mp4<br>direct1=fr <span class="hljs-comment"># 左上</span><br>direct2=re <span class="hljs-comment"># 右上</span><br>direct3=le <span class="hljs-comment"># 左下</span><br>direct4=ri <span class="hljs-comment"># 右下</span><br>w=1280<br>h=960<br><span class="hljs-comment">##############################################################################################</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$&#123;root&#125;</span><br><span class="hljs-built_in">rm</span> videos.txt<br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> *<span class="hljs-variable">$&#123;suffix&#125;</span>;<span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;file &quot;</span><span class="hljs-variable">$&#123;name&#125;</span><span class="hljs-string">&quot;&quot;</span>&gt;&gt;videos.txt;<span class="hljs-keyword">done</span><br>ffmpeg -f concat -safe 0 -i videos.txt -c copy concat<span class="hljs-variable">$&#123;suffix&#125;</span><br><span class="hljs-comment">##############################################################################################</span><br></code></pre></td></tr></table></figure><ol><li><h3 id="要在FFmpeg中使用多个显卡进行视频处理，你可以使用FFmpeg的-hwaccel选项和-c-v选项。"><a href="#要在FFmpeg中使用多个显卡进行视频处理，你可以使用FFmpeg的-hwaccel选项和-c-v选项。" class="headerlink" title="要在FFmpeg中使用多个显卡进行视频处理，你可以使用FFmpeg的-hwaccel选项和-c:v选项。"></a>要在FFmpeg中使用多个显卡进行视频处理，你可以使用FFmpeg的<code>-hwaccel</code>选项和<code>-c:v</code>选项。</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg -hwaccel_device 0,1 -hwaccel cuda -i input.mp4 -c:v h264_nvenc -gpu 0,1 output.mp4<br></code></pre></td></tr></table></figure><p>案例：2x2–&gt;4x1；多个视频合并成一个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 视频信息：地址、后缀名、前后左右顺序、分辨率</span><br>root=/home/calmcar/wly/Hozon_ep40/54_white <span class="hljs-comment"># 多个视频存放的目录</span><br>suffix=.mp4 <span class="hljs-comment"># 后缀</span><br>direct1=fr <span class="hljs-comment"># 左上</span><br>direct2=re <span class="hljs-comment"># 右上</span><br>direct3=le <span class="hljs-comment"># 左下</span><br>direct4=ri <span class="hljs-comment"># 右下</span><br>w=1280<br>h=960<br><span class="hljs-comment"># 合并视频</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$&#123;root&#125;</span><br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> *<span class="hljs-variable">$&#123;suffix&#125;</span>;<span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;file &quot;</span><span class="hljs-variable">$&#123;name&#125;</span><span class="hljs-string">&quot;&quot;</span> &gt;&gt; videos.txt;<span class="hljs-keyword">done</span><br>ffmpeg -f concat -safe 0 -i videos.txt -c copy concat<span class="hljs-variable">$&#123;suffix&#125;</span><br><span class="hljs-comment"># 2x2--&gt;4x1</span><br><span class="hljs-built_in">mkdir</span> results<br>video_name=concat<br>ffmpeg -i <span class="hljs-variable">$&#123;video_name&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span> -vf crop=<span class="hljs-variable">$w</span>:<span class="hljs-variable">$h</span>:0:0 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_<span class="hljs-variable">$&#123;direct1&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span><br>ffmpeg -i <span class="hljs-variable">$&#123;video_name&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span> -vf crop=<span class="hljs-variable">$w</span>:<span class="hljs-variable">$h</span>:<span class="hljs-variable">$w</span>:0 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_<span class="hljs-variable">$&#123;direct2&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span><br>ffmpeg -i <span class="hljs-variable">$&#123;video_name&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span> -vf crop=<span class="hljs-variable">$w</span>:<span class="hljs-variable">$h</span>:0:<span class="hljs-variable">$h</span> -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_<span class="hljs-variable">$&#123;direct3&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span><br>ffmpeg -i <span class="hljs-variable">$&#123;video_name&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span> -vf crop=<span class="hljs-variable">$w</span>:<span class="hljs-variable">$h</span>:<span class="hljs-variable">$w</span>:<span class="hljs-variable">$h</span> -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_<span class="hljs-variable">$&#123;direct4&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span><br>ffmpeg -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_fr<span class="hljs-variable">$&#123;suffix&#125;</span> -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_le<span class="hljs-variable">$&#123;suffix&#125;</span> -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_re<span class="hljs-variable">$&#123;suffix&#125;</span> -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_ri<span class="hljs-variable">$&#123;suffix&#125;</span> -filter_complex vstack=inputs=4 -b:v 3000k <span class="hljs-variable">$&#123;video_name&#125;</span>4<span class="hljs-variable">$&#123;suffix&#125;</span><br></code></pre></td></tr></table></figure><ol><li><h2 id="图片筛选时的一些便捷操作"><a href="#图片筛选时的一些便捷操作" class="headerlink" title="图片筛选时的一些便捷操作"></a>图片筛选时的一些便捷操作</h2></li><li><h3 id="当我们有一堆单视角图片，以前视角为准删除了相似帧图片后，希望将保留下来的同帧号左右后视角图片取出时，可以这么干"><a href="#当我们有一堆单视角图片，以前视角为准删除了相似帧图片后，希望将保留下来的同帧号左右后视角图片取出时，可以这么干" class="headerlink" title="当我们有一堆单视角图片，以前视角为准删除了相似帧图片后，希望将保留下来的同帧号左右后视角图片取出时，可以这么干"></a>当我们有一堆单视角图片，以前视角为准删除了相似帧图片后，希望将保留下来的同帧号左右后视角图片取出时，可以这么干</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 首先新建四个文件夹，用于保存各视角图片</span><br><span class="hljs-built_in">mkdir</span> fr<br><span class="hljs-built_in">mkdir</span> le<br><span class="hljs-built_in">mkdir</span> re<br><span class="hljs-built_in">mkdir</span> ri<br><span class="hljs-comment"># 首先通过文件名，将四个视角的图片分别保存至四视角文件夹</span><br><span class="hljs-built_in">mv</span> *_fr_* ./fr<br><span class="hljs-built_in">mv</span> *_le_* ./le<br><span class="hljs-built_in">mv</span> *_re_* ./re<br><span class="hljs-built_in">mv</span> *_ri_* ./ri<br><span class="hljs-comment"># 之后我们以前视角作为基准，找出其他文件夹中包含同视频编号、md5值和帧号的图片</span><br><span class="hljs-built_in">cd</span> fr <br><span class="hljs-built_in">ls</span> * &gt; ../fr.txt<br><span class="hljs-built_in">cd</span> ..<br><span class="hljs-comment"># 此时我们主目录中除保存四视角图片文件夹外，还有一个fr.txt中保存有所有前视角图片名</span><br><span class="hljs-comment"># 之后我们要对fr.txt做一些操作</span><br>vim fr.txt<br><span class="hljs-comment"># 在vim界面中输入</span><br>:%s/_fr_/_le_/g <span class="hljs-comment"># 这个命令表示将所有_fr_替换为_le_</span><br>:x <span class="hljs-comment"># 保存退出</span><br><span class="hljs-comment"># 之后在终端输入</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `<span class="hljs-built_in">cat</span> fr.txt`;<span class="hljs-keyword">do</span> <span class="hljs-built_in">mv</span> le/<span class="hljs-variable">$&#123;i&#125;</span> ./;<span class="hljs-keyword">done</span>;<br><span class="hljs-comment"># 这样操作就可以把左视角与前视角文件夹的交集图片取出</span><br><span class="hljs-comment"># 同样对右、后文件夹操作</span><br>vim fr.txt<br><span class="hljs-comment"># 在vim界面中输入</span><br>:%s/_le_/_re_/g <span class="hljs-comment"># 这个命令表示将所有_fr_替换为_le_</span><br>:x <span class="hljs-comment"># 保存退出</span><br><span class="hljs-comment"># 之后在终端输入</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `<span class="hljs-built_in">cat</span> fr.txt`;<span class="hljs-keyword">do</span> <span class="hljs-built_in">mv</span> re/<span class="hljs-variable">$&#123;i&#125;</span> ./;<span class="hljs-keyword">done</span>;<br>vim fr.txt<br><span class="hljs-comment"># 在vim界面中输入</span><br>:%s/_re_/_ri_/g <span class="hljs-comment"># 这个命令表示将所有_fr_替换为_le_</span><br>:x <span class="hljs-comment"># 保存退出</span><br><span class="hljs-comment"># 之后在终端输入</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `<span class="hljs-built_in">cat</span> fr.txt`;<span class="hljs-keyword">do</span> <span class="hljs-built_in">mv</span> ri/<span class="hljs-variable">$&#123;i&#125;</span> ./;<span class="hljs-keyword">done</span>;<br><span class="hljs-comment"># 最后将前视角文件夹中图片取出，删除四文件夹和fr.txt即可</span><br><span class="hljs-built_in">mv</span> ./fr/* ./<br><span class="hljs-built_in">rm</span> -r fr/ re/ ri/ le/ fr.txt<br></code></pre></td></tr></table></figure><ol><li><h3 id="遍历文件夹中所有文件（不带后缀）"><a href="#遍历文件夹中所有文件（不带后缀）" class="headerlink" title="遍历文件夹中所有文件（不带后缀）"></a>遍历文件夹中所有文件（不带后缀）</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">basename</span> --suffix=.png -- *.png<br></code></pre></td></tr></table></figure><ol><li><h2 id="Git-操作"><a href="#Git-操作" class="headerlink" title="Git 操作"></a>Git 操作</h2></li><li><h3 id="git-强制回退，删除已提交（慎用）"><a href="#git-强制回退，删除已提交（慎用）" class="headerlink" title="git 强制回退，删除已提交（慎用）"></a>git 强制回退，删除已提交（<em><strong>慎用</strong></em>）</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git reset --hard commit_id<br>git push --force origin 3dod<br></code></pre></td></tr></table></figure><ol><li><h3 id="git-本地仓库关联远程仓库"><a href="#git-本地仓库关联远程仓库" class="headerlink" title="git 本地仓库关联远程仓库"></a>git 本地仓库关联远程仓库</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git remote <span class="hljs-comment"># 查看当前有哪些远程仓库</span><br>git remote -v <span class="hljs-comment"># 列出当前仓库中已配置的远程仓库，并显示它们的 URL</span><br>git remote add &lt;本地仓库名&gt; &lt;远程仓库url&gt;  <span class="hljs-comment"># 本地仓库关联远程仓库</span><br>git remote <span class="hljs-built_in">rm</span>  &lt;远程仓库别名&gt;  <span class="hljs-comment"># 删除远程仓库</span><br></code></pre></td></tr></table></figure><ol><li><h3 id="Git分支操作"><a href="#Git分支操作" class="headerlink" title="Git分支操作"></a>Git分支操作</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git branch                  <span class="hljs-comment"># 查看分支</span><br>git branch  (branchname)     <span class="hljs-comment"># 创建新分支(branchname) </span><br>git checkout -b (branchname) <span class="hljs-comment"># 创建新分支并(branchname) 立即切换到该分支</span><br>git checkout (branchname)   <span class="hljs-comment"># 可以切换到分支(branchname) </span><br>git branch -d (branchname)  <span class="hljs-comment"># 可以删除分支(branchname) </span><br></code></pre></td></tr></table></figure><ol><li><h3 id="Git-本地仓库添加暂存文件"><a href="#Git-本地仓库添加暂存文件" class="headerlink" title="Git 本地仓库添加暂存文件"></a>Git 本地仓库添加暂存文件</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git add &lt;文件1&gt; &lt;文件1&gt; &lt;文件2&gt; &lt;文件3&gt; ...<br></code></pre></td></tr></table></figure><ol><li><h3 id="Git-命令来查看相关文件的状态-查看更新的详细信息"><a href="#Git-命令来查看相关文件的状态-查看更新的详细信息" class="headerlink" title="Git 命令来查看相关文件的状态&#x2F;查看更新的详细信息"></a>Git 命令来查看相关文件的状态&#x2F;查看更新的详细信息</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git status   <span class="hljs-comment"># 查看相关文件的状态</span><br>git diff     <span class="hljs-comment"># 查看尚未缓存的改动更新的详细信息</span><br>git diff --cached  <span class="hljs-comment"># 查看已缓存的改动： </span><br>git diff HEAD      <span class="hljs-comment"># 查看已缓存的与未缓存的所有改动：</span><br>git diff --<span class="hljs-built_in">stat</span>    <span class="hljs-comment"># 显示摘要而非整个 diff</span><br></code></pre></td></tr></table></figure><ol><li><h3 id="Git-取消已缓存的内容"><a href="#Git-取消已缓存的内容" class="headerlink" title="Git 取消已缓存的内容"></a>Git 取消已缓存的内容</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git reset HEAD test.txt   <span class="hljs-comment"># 用于取消已缓存的内容，如我们要取消已提交的test.txt文件.执行完之后，再使用commit提交时，test.txt文件不会被提交。</span><br></code></pre></td></tr></table></figure><ol><li><h3 id="Git-提交暂存文件"><a href="#Git-提交暂存文件" class="headerlink" title="Git 提交暂存文件"></a>Git 提交暂存文件</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git commit -m <span class="hljs-string">&quot;&lt;提交说明&gt;&quot;</span><br></code></pre></td></tr></table></figure><ol><li><h3 id="Git-提交修改到远程仓库"><a href="#Git-提交修改到远程仓库" class="headerlink" title="Git 提交修改到远程仓库"></a>Git 提交修改到远程仓库</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git push &lt;本地仓库名&gt; &lt;远程分支名&gt;<br></code></pre></td></tr></table></figure><ol><li><h3 id="git-拉取远程仓库"><a href="#git-拉取远程仓库" class="headerlink" title="git 拉取远程仓库"></a>git 拉取远程仓库</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git pull  <span class="hljs-comment">#相当于是从远程获取最新版本并merge到本地</span><br>git fetch  <span class="hljs-comment"># 相当于是从远程获取最新版本到本地，不会自动合并。</span><br></code></pre></td></tr></table></figure><ol><li><h3 id="Git合并操作"><a href="#Git合并操作" class="headerlink" title="Git合并操作"></a>Git合并操作</h3></li></ol><p>合并的时候，最大的难点就是冲突了，合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改，如果我们在两个分支中同时修改了同一个文件，这时再合并，就可能会产生冲突，冲突并不可怕，可怕的是要怎样去解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git merge branchname <span class="hljs-comment">#将任意分支合并到到当前分支中</span><br></code></pre></td></tr></table></figure><ol><li><h3 id="Git查看提交历史"><a href="#Git查看提交历史" class="headerlink" title="Git查看提交历史"></a>Git查看提交历史</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git <span class="hljs-built_in">log</span> <span class="hljs-comment"># 命令查看</span><br>git –oneline <span class="hljs-comment"># 查看历史记录的简洁版本</span><br>git –graph <span class="hljs-comment"># 查看历史中什么时候出现了分支、合并</span><br>git –reverse <span class="hljs-comment"># 逆向显示所有日志</span><br>git –author <span class="hljs-comment"># 查找指定用户的提交日志</span><br>git –since、–before、 --<span class="hljs-keyword">until</span>、–after <span class="hljs-comment"># 指定筛选日期</span><br>git –no-merges <span class="hljs-comment"># 选项以隐藏合并提交</span><br>git <span class="hljs-built_in">log</span> --autho <span class="hljs-comment"># 查找指定用户的提交日志</span><br></code></pre></td></tr></table></figure><ol><li><h3 id="Git-标签操作"><a href="#Git-标签操作" class="headerlink" title="Git 标签操作"></a>Git 标签操作</h3></li></ol><p>使用标签可以很方便的永远的记住那个特别的提交快照，比如：我们发一个新的版本时，可以给它加一个“vx.x”版本，这样你可以使用git tag给它打上标签。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git tag -a v1.0 <span class="hljs-comment"># 创建一个带注解的标签,可以很方便的永远的记住那个特别的提交快照</span><br>git tag <span class="hljs-comment"># 查看标签</span><br>git tag -a &lt;tagname&gt; -m <span class="hljs-string">&quot;某某标签&quot;</span> <span class="hljs-comment">#指定标签信息</span><br>git tag -a v1.0 d6f7147 <span class="hljs-comment"># d6f7147提交已发布，可对其追加标签 </span><br>git checkout tag_name <span class="hljs-comment"># 但是，这时候 git 可能会提示你当前处于一个“detached HEAD&quot; 状态。因为 tag 相当于是一个快照，是不能更改它的代码的。如果要在 tag 代码的基础上做修改，你需要一个分支： git checkout -b branch_name tag_name</span><br></code></pre></td></tr></table></figure><ol><li><h3 id="配置-gitignore文件"><a href="#配置-gitignore文件" class="headerlink" title="配置.gitignore文件"></a><code>配置.gitignore</code>文件</h3></li></ol><p>把要忽略的文件名填进去，Git就会自动忽略这些文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 忽略所有.开头的隐藏文件:</span><br>.*<br><span class="hljs-comment"># 忽略所有.class文件:</span><br>*.class<br><br><span class="hljs-comment"># 排除忽略.gitignore和App.class:</span><br>!.gitignore<br>!App.class<br></code></pre></td></tr></table></figure><ol><li><h2 id="一些有用的小工具"><a href="#一些有用的小工具" class="headerlink" title="一些有用的小工具"></a>一些有用的小工具</h2></li><li><h3 id="pigz多线程压缩"><a href="#pigz多线程压缩" class="headerlink" title="pigz多线程压缩"></a>pigz多线程压缩</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-get install -y pigz<br>tar cv filename | pigz -9 -p16 -k &gt; filename.tar.gz<br><span class="hljs-comment"># -9 为压缩级别 -p16为调用线程数量 -k为保留源文件</span><br></code></pre></td></tr></table></figure><ol><li><h3 id="多线程apt-fast"><a href="#多线程apt-fast" class="headerlink" title="多线程apt-fast"></a>多线程apt-fast</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-add-repository ppa:apt-fast/stable<br>sudo apt-get install apt-fast<br></code></pre></td></tr></table></figure><ol><li><h3 id="conda环境迁移"><a href="#conda环境迁移" class="headerlink" title="conda环境迁移"></a>conda环境迁移</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">conda install conda-pack conda-pack<br>conda pack -p /path/to/env -o env_name.tar.gz<br>tar zxcf env_name.tar.gz -C env_name<br><span class="hljs-built_in">source</span> env_name/bin/activate<br>conda un<br></code></pre></td></tr></table></figure><ol><li><h2 id="shell网络命令"><a href="#shell网络命令" class="headerlink" title="shell网络命令"></a>shell网络命令</h2></li><li><h3 id="ssh进行远程登录和执行命令"><a href="#ssh进行远程登录和执行命令" class="headerlink" title="ssh进行远程登录和执行命令"></a>ssh进行远程登录和执行命令</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ssh user@host  <span class="hljs-comment"># user是要登录的用户名，host是要登录的主机名或IP地址</span><br>ssh -L 8080:localhost:80 user@example.com <span class="hljs-comment"># 创建一个SSH隧道，将本地端口8080转发到远程主机http://example.com的80端口</span><br></code></pre></td></tr></table></figure><ol><li><h3 id="使用scp进行文件传输"><a href="#使用scp进行文件传输" class="headerlink" title="使用scp进行文件传输"></a>使用scp进行文件传输</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">scp root@192.168.0.101:/var/www/test.txt /var/www/local_dir（本地目录） <span class="hljs-comment"># scp root@192.168.0.101:/var/www/test.txt 把192.168.0.101上的/var/www/test.txt 的文件下载到/var/www/local_dir（本地目录）</span><br>scp -r root@192.168.0.101:/var/www/test（远程目录）   /var/www/（本地目录）<br>scp example.txt user@example.com:/home/user <span class="hljs-comment"># 将本地文件example.txt传输到远程主机http://example.com的/home/user目录下</span><br>scp -r <span class="hljs-built_in">test</span> （本地目录） root@192.168.0.101:/var/www/（远程目录） <span class="hljs-comment"># 把当前目录下的test目录上传到服务器的/var/www/ 目录</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ffmpeg</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
