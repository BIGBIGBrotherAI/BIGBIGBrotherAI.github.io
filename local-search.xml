<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>自标定流程设计</title>
    <link href="/2024/04/10/%E8%87%AA%E6%A0%87%E5%AE%9A%E6%B5%81%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/04/10/%E8%87%AA%E6%A0%87%E5%AE%9A%E6%B5%81%E7%A8%8B%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<ul><li>流程一</li></ul><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/202404101125969.png"alt="道路标定流程图" /><figcaption aria-hidden="true">道路标定流程图</figcaption></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>道路标定入门</title>
    <link href="/2024/04/08/%E9%81%93%E8%B7%AF%E6%A0%87%E5%AE%9A%E5%85%A5%E9%97%A8/"/>
    <url>/2024/04/08/%E9%81%93%E8%B7%AF%E6%A0%87%E5%AE%9A%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="道路标定介绍">1.道路标定介绍</h2><p>​道路标定是自动驾驶系统中的一个重要概念。它是指通过车辆传感器和算法的组合，对道路和车道进行精确定位和辨识的过程。道路标定是自动驾驶系统实现精确导航、路径规划和障碍物检测的基础。它通常包括对道路几何结构、车道线和交通信号灯等进行标定和辨识。道路标定可以通过使用高精度地图数据、GPS和视觉传感器等进行实现。​在道路标定领域，环视相机也可以用于实现道路和车道的精确标定。环视相机的道路标定通常包括以下几个步骤：</p><ol type="1"><li>图像矫正：由于摄像头的放置位置可能会出现视角变形和畸变，需要对摄像头捕捉到的图像进行矫正，使得道路和车辆的几何结构在图像中表现更加准确。图像矫正可以通过使用相机标定的参数，对图像进行几何变换和畸变校正来实现。</li><li>车道线以及其他路面特征基准检测：接下来，利用矫正后的图像，可以使用计算机视觉算法对车道线进行检测和提取。常见的车道线检测算法包括Hough变换、Canny边缘检测和基于深度学习的方法。通过车道线检测，可以确定车道的位置、宽度和形状等信息。</li><li>车道线跟踪：一旦车道线被检测到，下一步是进行车道线的跟踪。车道线跟踪可以通过建立车道模型和使用滤波器或曲线拟合算法来实现。通过跟踪车道线，可以获取车道线的动态信息，并帮助车辆实时调整行驶路径。</li><li>相机标定：首先，需要对每个相机进行校准，以获得相机的内部参数和外部参数。相机内部参数包括焦距、主点和畸变参数等，外部参数则表示相机在车辆上的位置和朝向。相机标定可以通过拍摄特定的标定板，并使用标定算法来计算相机的参数。</li></ol><p>​通过以上步骤，环视相机可以实现对道路和车道的准确标定。这可以提供给驾驶员一个全景视野，帮助他们更好地感知和理解道路环境。对于自动驾驶系统而言，环视相机的道路标定可以为系统提供更可靠的环境感知和决策基础，从而实现安全、高效的自动驾驶体验。</p><h2 id="道路标定方案以及行业调研">2.道路标定方案以及行业调研</h2><p><a href="#">CC_道路标定方案及行业产品分析_20230509.pptx</a> <ahref="#">CC_道路标定方案_20230808.pptx</a></p><h2 id="道路标定测流程分析">3.道路标定测流程分析</h2><p>20240325：<a href="#">道路标定流程图_20240325.drawio</a></p><figure><imgsrc="http://wiki.calmcar.com:8090/download/attachments/115237154/道路标定流程图.png?version=2&amp;modificationDate=1711334327000&amp;api=v2"alt="Zeekr项目 &gt; 道路标定资料-ZEEKR &gt; 道路标定流程图.png" /><figcaption aria-hidden="true">Zeekr项目 &gt; 道路标定资料-ZEEKR &gt;道路标定流程图.png</figcaption></figure><p>下一步：check_pose()同时check R （pitch±3°，roll,yaw±2°）和 T(x,y,z ±3cm)。道路标定参数独立设置。</p><p>左右相机的标定流程</p><h2 id="zeekr项目-道路标定资料-zeekr-image2024-3-26_10-5-59.png"><imgsrc="http://wiki.calmcar.com:8090/download/attachments/115237154/image2024-3-26_10-5-59.png?version=1&amp;modificationDate=1711418758000&amp;api=v2"alt="Zeekr项目 &gt; 道路标定资料-ZEEKR &gt; image2024-3-26_10-5-59.png" /></h2><h2 id="理论支撑以及相关理论研究">4.理论支撑以及相关理论研究</h2><ol type="1"><li><a href="#">online_calib.pdf</a>备注:只涉及到路面消失点部分,可以通过外参计算出图像投影到鸟瞰图的单应矩阵H，因此可以将去畸变图上的车道线投影到鸟瞰图上。认为当鸟瞰图上车道线几乎垂直于图像x轴的时候，外参标定的比较准确。</li><li>[<a href="https://arxiv.org/abs/2305.16840">2305.16840] AutomaticSurround Camera Calibration Method in Road Scene for Self-driving Car(arxiv.org)</a></li></ol><p>上文总结 备注:</p><ol type="1"><li><ol type="1"><li><ol type="1"><li>生成BEV图像：<ol type="1"><li>使用相机的初始外参将图像投影到BEV视图中。</li><li>利用OpenCV库检测相邻两台相机的BEV图像的<strong>公共区域，并提取出该区域的轮廓</strong>。</li></ol></li><li>提取纹理点：<ol type="1"><li><strong>计算BEV图像中每个像素的光度梯度，如果梯度的L2范数小于阈值，则将该像素视为纹理点。</strong></li><li>考虑到不同相机的曝光条件，可以<strong>通过曝光时间的比例因子来近似校正</strong>。</li></ol></li><li>计算光度误差：<ol type="1"><li>将相机Ci的BEV图像中的纹理点投影回相机Cj的图像，获取对应像素。</li><li>计算相机Ci的BEV图像与相机Cj的图像之间的光度误差，通过最小化光度误差来优化相机的外参。<ol type="1"><li>优化相机外参的主干公式如下：计算两台相邻相机的BEV图像之间的光度误差εpG，公式为： εpG = ||IGCi(pG) -ICj(pj)||其中，IGCi是相机Ci的BEV图像，ICj是相机Cj的图像，pG是相机Ci的BEV图像中的纹理点坐标，pj是pG在相机Cj图像中的对应坐标。通过最小化光度误差εpG来优化相机的外参。在优化过程中，将相机Ci的BEV图像中的纹理点pG投影回相机Cj的图像中，得到对应坐标pj，然后计算光度误差εpG，并通过最小化该误差来优化相机Cj的外参TCjG。综上所述，通过最小化两台相邻相机的BEV图像之间的光度误差εpG，实现相机外参的优化。</li></ol></li></ol></li></ol></li></ol></li></ol><p>3.<ahref="https://wenku.baidu.com/view/fa47149b8c9951e79b89680203d8ce2f01666570?fr=xueshu_top">一种基于自然场景的车身环视相机自标定方法和系统</a></p><p>​ 上文为专利，流程总结：</p><p>在车辆行驶过程中，利用周围环境中的自然特征（如道路、建筑物等）来进行相机的自标定。这种方法的关键步骤通常包括：</p><ol type="1"><li><ol type="1"><li><ol type="1"><li><strong>初始位姿估计</strong>：在标定开始时，系统需要估计相机的初始位姿。这通常是通过分析相机捕获的初始图像来完成的，可能涉及到图像处理技术，如边缘检测、特征提取等。</li><li><strong>数据采集</strong>：在车辆行驶过程中，系统不断采集图像数据和环境信息。这些数据用于后续的标定计算。</li><li><strong>里程计数据融合</strong>：结合车辆的里程计数据（如车轮转数、速度等），可以更准确地计算相机在空间中的移动和位姿变化。</li><li><strong>变换矩阵计算</strong>：通过分析相邻图像之间的对应关系，计算单个相机与里程计之间的变换矩阵。这有助于确定相机在车辆坐标系中的位置和方向。</li><li><strong>地图构建</strong>：在车辆行驶过程中，系统还构建了一个周围环境的地图。这个地图不仅用于当前的标定过程，还可以用于后续的导航和路径规划。</li><li><strong>相邻相机间变换矩阵计算</strong>：对于多相机系统，还需要计算相邻相机之间的变换矩阵，以便将所有相机的视角融合成一个连贯的全景视图。</li><li><strong>求解由原图到bev的H矩阵</strong>。</li></ol></li></ol></li></ol><h2 id="当前算法细节的困难">5.当前算法细节的困难</h2><ol type="1"><li>车辅线检测的鲁棒性还是不够；<ol type="1"><li>在单视角完全矫畸变的图上检测消失点，算法稳定；</li><li>在前后bev以及左右融合bev上检出车道线的边界，效果不稳定；<ol type="1"><li>虚线车道线存在中断；</li><li>车道线可能存在破损有残缺；</li><li>车道线老旧或者逆光拍摄车道线，车道线颜色较浅或者对比度不明显；</li></ol></li></ol></li><li>现在融合效果不佳，后相机没参与融合。使用消失点标定前相机后，将左右初始bev的车道线检出边界与前bev的检出边界进行对正拉图融合（前不变，左右变），后相机没参与融合；</li><li>设想的约束住T（因为相机的安装位置一般比较稳定误差较小）,求解H的方法；</li><li>后相机RT转H再逆变换的精度损失问题（前相机RT转H再逆变换误差较小）。<ahref="http://wiki.calmcar.com:8090/pages/viewpage.action?pageId=115242828">标定结果中的RT和H互逆性的问题- Zeekr项目 - CalmCar</a></li></ol><h2 id="常识介绍">6. 常识介绍</h2><ol type="1"><li>在自标定算法中，我们要求车身与车道线平行，这样消失点的Z方向坐标才能远大于X和Y，算法的公式是基于这样的假设进行推导的。<imgsrc="https://pic1.zhimg.com/80/v2-a99fac7518fdcb759d00b8c279946c68_720w.webp"alt="img" />在这种情况下，图像上消失点的x方向坐标，应该在width/2的位置上。因此，如果消失点计算的结果与图像x方向的中心位置偏差较多，说明车没有平行于车道线行驶，或者一切其他的原因。总之，要排除掉这种情况。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>标定结果中RT与欧拉角互逆性的问题</title>
    <link href="/2024/04/08/%E6%A0%87%E5%AE%9A%E7%BB%93%E6%9E%9C%E4%B8%ADRT%E4%B8%8E%E6%AC%A7%E6%8B%89%E8%A7%92%E4%BA%92%E9%80%86%E6%80%A7%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2024/04/08/%E6%A0%87%E5%AE%9A%E7%BB%93%E6%9E%9C%E4%B8%ADRT%E4%B8%8E%E6%AC%A7%E6%8B%89%E8%A7%92%E4%BA%92%E9%80%86%E6%80%A7%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>在射影几何学中，RT刚体变换和单应性矩阵变换都是可逆的，但它们的可逆性含义略有不同。</p><ol type="1"><li><strong>RT刚体变换</strong>：</li></ol><p>- RT刚体变换通常由一个旋转矩阵 <strong><em>R</em></strong>和一个平移向量 <strong>T*</strong> 组成。 - 旋转矩阵<strong><em>R</em></strong>是一个正交矩阵，意味着它的逆矩阵就是它的转置矩阵，即<strong><em>R</em></strong><sup>-1</sup>=<strong><em>R</em></strong><sup>T</sup>。- 平移向量<strong><em>T</em></strong>的逆变换是它的相反数，即<strong><em>-T</em></strong>。 -因此，RT刚体变换的逆变换是<strong><em>R</em></strong><sup>T</sup><strong>和-T</strong>的组合，这是<strong>可逆</strong>的。</p><ol start="2" type="1"><li><strong>单应性矩阵H变换</strong>：</li></ol><p>- 单应性矩阵是一个3x3的矩阵，用于描述两个平面之间的射影变换。 -单应性矩阵的逆矩阵存在当且仅当该单应性矩阵的行列式不为零。 -当行列式不为零时，单应性矩阵变换是可逆的，这意味着可以通过逆矩阵将变换逆向执行。总结来说，RT<strong><u>刚体变换总是可逆</u></strong>的，因为旋转和平移都有明确的逆操作。而<strong>单应性矩阵变换在<u>行列式不为零</u>的情况下是可逆</strong>的，这取决于具体的变换矩阵。</p><p>假设如下场景，对于一台已经标定好的环视相机，在相机前的三维空间有一批3D点。我们可以通过标定结果中的RT或者H把这些3D点转换到鱼眼坐标系的2D点，然后再通过标定结果中的RT或者H把这些2D点投影到Bev中去。现在做假设：1.标定完全准确；2.三维空间有一批3D点的z值为0。那么Bev中的点相对于后轴中心的位置与三维空间中的点相对于后轴中心的位置<strong>应当</strong>一致，加入引入一些转换损失，也应当保持较小的误差。</p><p>但是在实际的标定结果中，使用RT将三维空间有一批3D点投影到鱼眼，再使用H矩阵投影到bev后，发生了较大的误差。这说明：<strong>RT刚体变换</strong>和<strong>单应性矩阵H变换</strong>并不能<strong>完全</strong>互相转换。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>标定结果中的RT和H互逆性的问题</title>
    <link href="/2024/04/08/%E6%A0%87%E5%AE%9A%E7%BB%93%E6%9E%9C%E4%B8%AD%E7%9A%84RT%E5%92%8CH%E4%BA%92%E9%80%86%E6%80%A7%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2024/04/08/%E6%A0%87%E5%AE%9A%E7%BB%93%E6%9E%9C%E4%B8%AD%E7%9A%84RT%E5%92%8CH%E4%BA%92%E9%80%86%E6%80%A7%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="使用eigen求解">使用eigen求解</h2><p>现在有一辆车,进行过eol标定。其标定结果如下表。<strong>目前的结论是：eigen转化R矩阵到欧拉角不准确。</strong></p><p>对应的原rt文件如：<a href="#">cc_svs_params_out_008.xml</a> <ahref="#">extrinsic_008.xml</a></p><p>具体如下：</p><ul><li><p>front_r:</p><p>9.9999185273729763e-01, -1.4001286979320763e-03,3.7860399702453747e-03, -3.9705549499231075e-03, -5.1019285187180718e-01,8.6005086395648833e-01, 7.2742863341338383e-04,-8.6005888957590637e-01, -5.1019425448454592e-01</p></li><li><p>left_r:</p><p>-9.2646009441309379e-03 ,6.7136853981002731e-01,-7.4106575344074355e-01 ,9.9989272825131936e-01,-2.1879621715446378e-03, -1.4482569235759263e-02,-1.1344565195664548e-02, -7.4112043324610011e-01,-6.7127625033635308e-01</p></li><li><p>rear_r:</p><p>-9.9993380979667956e-01 ,1.1254483785363260e-02,2.3901088307984081e-03 ,2.9754730937093894e-03 , 4.5362472069214521e-01,-8.9118783616970609e-01 , -1.1114071502679677e-02,-8.9112173656111615e-01 , -4.5362818259333776e-01</p></li><li><p>right_r:</p><p>-9.4426695241620097e-03, -6.7318106864383931e-01,7.3941739552961327e-01, -9.9987163497538067e-01, -3.2155644340346452e-03,-1.5696296283832810e-02, 1.2944093785072519e-02,-7.3947069513599339e-01, -6.7306429222710518e-01</p></li></ul><p>转换成具体角度如表1(使用原转换方法。接近但有误差。)</p><p><strong>表1 eol标定的角度真值</strong></p><table style="width:100%;"><thead><tr class="header"><th></th><th></th><th>pitch(° )</th><th>roll(° )</th><th>yaw(° )</th><th></th><th></th></tr></thead><tbody><tr class="odd"><td>原始</td><td>front</td><td>-27.753000259399414</td><td>0.041678592562675476</td><td>-0.21692462265491486</td><td></td><td></td></tr><tr class="even"><td>left</td><td>-42.165641784667969</td><td>-0.65000957250595093</td><td>0.82981908321380615</td><td></td><td></td><td></td></tr><tr class="odd"><td>rear</td><td>-26.976701736450195</td><td>-0.63680243492126465</td><td>0.13694326579570770</td><td></td><td></td><td></td></tr><tr class="even"><td>right</td><td>-42.304012298583984</td><td>0.74166262149810791</td><td>-0.89936840534210205</td><td></td><td></td><td></td></tr></tbody></table><p>使用eigen的接口转换结果如表2.为了排除定义的影响。又分别针对各个相机对原R矩阵<strong>分别</strong>乘了绕x轴,绕y轴,绕z轴cam_id*π/2的eigen旋转向量，再求解eigen的欧拉角。如表2.</p><p><strong>表2 eigen转换eol标定的RT</strong></p><table style="width:100%;"><thead><tr class="header"><th></th><th>转动轴</th><th>x^(° )</th><th>y^(° )</th><th>z^(° )</th><th></th><th>备注</th><th></th></tr></thead><tbody><tr class="odd"><td>eigen直接转换R到欧拉角结果</td><td>front</td><td>59.3232</td><td>-179.958</td><td>179.773</td><td></td><td></td><td></td></tr><tr class="even"><td>left</td><td>-132.169</td><td>0.65001</td><td>90.5309</td><td></td><td></td><td></td><td></td></tr><tr class="odd"><td>rear</td><td>-116.979</td><td>0.636803</td><td>179.83</td><td></td><td></td><td></td><td></td></tr><tr class="even"><td>right</td><td><strong>47.6916</strong></td><td>-179.258</td><td>89.4589</td><td></td><td></td><td></td><td></td></tr><tr class="odd"><td>eigenR加个补偿角(X轴)-n*pi/2到欧拉角的结果,再映射到原始数据的(n=0,1,2,3前左后右)</td><td>front</td><td>59.3232</td><td>-179.958</td><td>179.773</td><td>绕X轴反转0*pi/2</td><td>勉强对应</td><td></td></tr><tr class="even"><td>left</td><td><strong>47.831</strong></td><td>0.65001</td><td>90.5309</td><td>绕X轴反转pi/2</td><td>对应</td><td></td><td></td></tr><tr class="odd"><td>rear</td><td>63.0215</td><td>0.636803</td><td>179.83</td><td>绕X轴反转2pi/2</td><td>对应</td><td></td><td></td></tr><tr class="even"><td>right</td><td><strong>137.692</strong></td><td>-179.258</td><td>89.4589</td><td>绕X轴反转3pi/2</td><td>勉强对应</td><td></td><td></td></tr><tr class="odd"><td>eigenR加个补偿角(Y轴)-n*pi/2到欧拉角的结果,再映射到原始数据的(n=0,1,2,3前左后右)</td><td>front</td><td>59.3232°</td><td>-179.958°</td><td>179.773°</td><td>绕Y轴反转0*pi/2</td><td>对应</td><td></td></tr><tr class="even"><td>left</td><td><strong>90.877°</strong></td><td><strong>137.834°</strong></td><td><strong>1.11958°</strong></td><td>绕Y轴反转pi/2</td><td>对不上</td><td></td><td></td></tr><tr class="odd"><td>rear</td><td><strong>90.7146°</strong></td><td><strong>153.023°</strong></td><td><strong>90.1537°</strong></td><td>绕Y轴反转2pi/2</td><td>对不上</td><td></td><td></td></tr><tr class="even"><td>right</td><td><strong>-88.9972</strong></td><td><strong>-42.304</strong></td><td><strong>178.784</strong></td><td>绕Y轴反转3pi/2</td><td>对不上</td><td></td><td></td></tr><tr class="odd"><td>eigenR加个补偿角(Z轴)-n*pi/2到欧拉角的结果,再映射到原始数据的(n=0,1,2,3前左后右)</td><td>front</td><td>59.3232°</td><td>-179.958°</td><td>179.773°</td><td>绕Z轴反转0*pi/2</td><td>对应</td><td></td></tr><tr class="even"><td>left</td><td><strong>-179.032°</strong></td><td><strong>-47.8269°</strong></td><td><strong>179.813°</strong></td><td>绕Z轴反转pi/2</td><td>对不上</td><td></td><td></td></tr><tr class="odd"><td>rear</td><td><strong>-63.0215°</strong></td><td><strong>-179.363°</strong></td><td><strong>179.83°</strong></td><td>绕Z轴反转2pi/2</td><td>对不上</td><td></td><td></td></tr><tr class="even"><td>right</td><td><strong>1.10175°</strong></td><td><strong>132.314°</strong></td><td><strong>0.273681°</strong></td><td>绕Z轴反转3pi/2</td><td>对不上</td><td></td><td></td></tr></tbody></table><p>为了实现从表2到表1的转换,分别给以补偿去逼近。补偿方法见表3。</p><p><strong>表 3 表2到表1的补偿</strong></p><table><thead><tr class="header"><th></th><th>转动轴</th><th>x^(° )-&gt;pitch</th><th>y^(° )-&gt;roll</th><th>z^(° )-&gt;yaw</th><th></th><th></th><th></th></tr></thead><tbody><tr class="odd"><td>eigen直接转换R到欧拉角的结果,再映射到原始数据的补偿值</td><td>front</td><td>-90</td><td>+180</td><td>-180</td><td></td><td></td><td></td></tr><tr class="even"><td>left</td><td>+90</td><td>*-1</td><td>-90</td><td></td><td></td><td></td><td></td></tr><tr class="odd"><td>rear</td><td>+90</td><td>*-1</td><td>180-</td><td></td><td></td><td></td><td></td></tr><tr class="even"><td>right</td><td>-90</td><td>+180</td><td>-90</td><td></td><td></td><td></td><td></td></tr><tr class="odd"><td>eigen R加个补偿角-n*pi/2到欧拉角的结果,再映射到原始数据的(n=0,1,2,3前左后右),再映射到原始数据的补偿值</td><td>front</td><td>-90</td><td>+180</td><td>-180</td><td>绕X轴反转0*pi/2</td><td></td><td></td></tr><tr class="even"><td>left</td><td>-90</td><td>*-1</td><td>-90</td><td>绕X轴反转pi/2</td><td></td><td></td><td></td></tr><tr class="odd"><td>rear</td><td>-90</td><td>*-1</td><td>180-</td><td>绕X轴反转2pi/2</td><td></td><td></td><td></td></tr><tr class="even"><td>right</td><td>-180</td><td>+180</td><td>90-</td><td>绕X轴反转3pi/2</td><td></td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td><td></td><td></td><td>绕Y轴反转0*pi/2</td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td><td></td><td></td><td>绕Y轴反转pi/2</td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td><td></td><td></td><td>绕Y轴反转2pi/2</td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td><td></td><td></td><td>绕Y轴反转3pi/2</td><td></td><td></td></tr></tbody></table><p><strong>表3</strong></p><table><thead><tr class="header"><th></th><th>转动轴</th><th>x^(° )</th><th>y^(° )</th><th>z^(° )</th><th></th><th></th></tr></thead><tbody><tr class="odd"><td>eigen R加个补偿角-n*pi/2到欧拉角的结果,再映射到原始数据的</td><td>front</td><td>59.3232</td><td>-179.958</td><td>179.773</td><td>绕X轴反转0*pi/2</td><td></td></tr><tr class="even"><td>left</td><td>47.831</td><td>0.65001</td><td>90.5309</td><td>绕X轴反转pi/2</td><td></td><td></td></tr><tr class="odd"><td>rear</td><td>63.0215</td><td>0.636803</td><td>179.83</td><td>绕X轴反转2pi/2</td><td></td><td></td></tr><tr class="even"><td>right</td><td>137.692</td><td>-179.258</td><td>89.4589</td><td>绕X轴反转3pi/2</td><td></td><td></td></tr><tr class="odd"><td></td><td>转动轴</td><td>x^(° )-&gt;pitch</td><td>y^(° )-&gt;roll</td><td>z^(° )-&gt;yaw</td><td></td><td></td></tr><tr class="even"><td>补偿值</td><td>front</td><td>-90</td><td>+180</td><td>-180</td><td></td><td></td></tr><tr class="odd"><td>left</td><td>-90</td><td>*-1</td><td>-90</td><td></td><td></td><td></td></tr><tr class="even"><td>rear</td><td>-90</td><td>*-1</td><td>180-</td><td></td><td></td><td></td></tr><tr class="odd"><td>right</td><td>-180</td><td>+180</td><td>90-</td><td></td><td></td><td></td></tr></tbody></table><h2 id="补充知识">补充知识</h2><h3 id="eigen的旋转api">eigen的旋转api</h3><p>Eigen库旋转向量使用 AngleAxis</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Eigen</span>::AngleAxisd rotation_vector ( M_PI/<span class="hljs-number">4</span>, Eigen::Vector3d ( <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span> ) ); //角+轴：沿 Z 轴旋转 <span class="hljs-number">45</span> 度 Eigen::AngleAxisd rotation_vector ( M_PI/<span class="hljs-number">4</span>, Eigen::Vector3d::UnitZ()); //角+轴：沿 Z 轴旋转 <span class="hljs-number">45</span> 度<br></code></pre></td></tr></table></figure><p>Eigen库 旋转向量转换旋转矩阵：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">rotation_matrix = rotation_vector.matrix<span class="hljs-params">()</span>  <span class="hljs-string">//</span>旋转向量<span class="hljs-params">------</span>&gt;旋转矩阵 rotation_matrix = rotation_vector.toRotationMatrix<span class="hljs-params">()</span>; <span class="hljs-string">//</span>旋转向量<span class="hljs-params">------</span>&gt;旋转矩阵<br></code></pre></td></tr></table></figure><p>Eigen库 旋转矩阵转换旋转向量：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">Eigen:<span class="hljs-function">:AngleAxisd</span> rotation_vector; rotation_vector.fromRotationMatrix<span class="hljs-params">(rotation_matrix)</span>;<span class="hljs-string">//</span>旋转矩阵<span class="hljs-params">------</span>&gt;旋转向量 rotation_vector<span class="hljs-params">(rotation_matrix)</span>;<span class="hljs-string">//</span>旋转矩阵<span class="hljs-params">------</span>&gt;旋转向量<br></code></pre></td></tr></table></figure><p>Eigen库可以将旋转矩阵直接转换成欧拉角</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Eigen</span>::Vector3d euler_angles = rotation_matrix.eulerAngles ( <span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span> ); // ZYX顺序,即yaw pitch roll顺序<br></code></pre></td></tr></table></figure><h3 id="eigen旋转矩阵以及旋转坐标系">eigen旋转矩阵以及旋转坐标系</h3><h3 id="cc-旋转矩阵">CC 旋转矩阵</h3><ol type="1"><li><p>相机坐标系是右手坐标系。x轴指向相机右侧，y轴指向相机下，z轴由相机光心指向前；x_rot逆时针为pitch正，y_rot逆时针为yaw正，z_rot逆时针为roll正。旋转时都是按照先转z_rot（roll）,再转y_rot（yaw）,再转x_rot（pitch）的顺序进行的。</p><p>但需要注意两点：</p><ol type="1"><li>文件中记录的pitch角类似-27°，-56°这些负角度等等，<strong>但实际上从相机实际位置旋转到bev（后轴中心）,是旋转了(90-(-27))°，(90-(-56))°，(90-(pitch))</strong>。这也是R中对应的x的实际逆时针旋转角度；</li><li>对于不同的相机，pitch/yaw/roll记录的角度有偏差，偏差1是上一条所提内容，偏差2是在修正偏差1的情况下，只能将各个相机的图像旋转到bev前侧区域（后轴中心）。左右后还要在bev前侧区域的坐标轴下分别逆时针旋转pi/2 , pi , 3*pi/2 的角度才能到bev的左/后/右区域。</li></ol></li><li><p>CC计算旋转矩阵的过程</p></li></ol><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/202404101035891.png"alt="图1 相机坐标系" /><figcaption aria-hidden="true">图1 相机坐标系</figcaption></figure><p>​</p><p>​</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/202404101034013.png"alt="图2 RT矩阵计算流程" /><figcaption aria-hidden="true">图2 RT矩阵计算流程</figcaption></figure><p>​</p><p><img src="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/202404101033792.png" alt="图3  旋转矩阵的推导" style="zoom:67%;" /></p><p>​</p><h3id="万向节死锁导致欧拉角不唯一"><strong>万向节死锁导致欧拉角不唯一</strong></h3><p>当两个旋转轴重合时，系统的自由度减少，导致一个方向的旋转不再独立，这种现象称为<strong>万向节死锁</strong>。</p><p>万向节死锁导致的问题？</p><p>当使用<strong>欧拉角</strong>描述旋转时，万向节死锁发生的情况通常是这样的：</p><ol type="1"><li><p><strong>初始状态</strong>：物体有三个独立的旋转轴，分别对应俯仰、偏航和翻滚。</p></li><li><p><strong>死锁发生</strong>：当物体先进行一定程度的俯仰旋转，然后再进行偏航旋转时，俯仰和偏航的旋转轴可能会重合。这时，物体的一个旋转轴（通常是翻滚轴）会与俯仰轴或偏航轴对齐。</p></li><li><p><strong>自由度减少</strong>：在死锁状态下，物体失去了一个旋转自由度。这意味着，使用三个欧拉角无法唯一描述物体的旋转状态。（这时，第三个轴的旋转不再独立，导致物体实际上只有两个独立的旋转自由度。当两个这样的轴对齐时，例如俯仰轴和偏航轴指向同一方向或相反方向，物体的旋转自由度会减少。）。</p></li><li><p><strong>求解问题</strong>：当尝试从这种状态的旋转矩阵中求解欧拉角时，由于自由度的减少，可能会出现<strong>多组不同的欧拉角对应同一个旋转矩阵</strong>的情况。这导致从旋转矩阵求解欧拉角时出现不确定性或错误。在死锁状态下，<strong>通常存在两组不同</strong>的欧拉角可以描述同一个旋转状态。这两组解是通过对称性得到的。具体来说：</p><ol type="1"><li>一组解：直接从旋转矩阵得到的欧拉角。</li><li>另一组解：由于旋转轴对齐，可以通过将其<strong>中一个轴的旋转角度增加或减少180°来获得另一组解</strong>。例如，如果俯仰轴和偏航轴对齐，那么俯仰角增加或减少180°将得到另一组描述相同旋转状态的欧拉角。</li></ol></li><li><p>打破eigen死锁的可能途径（未验证）：</p><ol type="1"><li><strong>检测万向节死锁</strong>:通过检查旋转矩阵中的某些元素是否接近0或1来实现。例如，如果旋转矩阵中的某个元素接近1或-1;</li><li><strong>调整旋转矩阵:</strong>可以通过添加一个非常小的偏移量到旋转矩阵来实现，从而打破轴对齐的状态。例如，可以沿着非对齐的轴添加一个微小的旋转;</li><li><strong>处理角度限制</strong>:Eigen库可能对欧拉角施加了某些限制，例如将角度限制在-90° 到 90° 之间。</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++语法糖</title>
    <link href="/2024/01/26/C-%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <url>/2024/01/26/C-%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    
    <content type="html"><![CDATA[<p>C++语法糖（syntacticsugar）是指一些语法结构或表达式，虽然并不增加语言的能力，但是可以使得代码更加简洁、易读、易写、易理解和易维护。这些语法结构或表达式并不是必需的，但它们使得编程更加方便、快捷和高效。</p><ol type="1"><li><ahref="https://zhuanlan.zhihu.com/p/621673847">引用：C++中引入了引用类型，可以通过&amp; 操作符定义，它是指向已存在变量的别名，使用起来更加方便。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/621674315">函数重载：C++中可以通过函数重载来定义多个同名函数，它们的参数列表不同，使得程序员能够更方便地调用不同类型的函数。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/621841277">运算符重载：C++中可以通过运算符重载来对C++内置的运算符进行重新定义，使得运算符能够适用于自定义类型。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/621845124">类和对象：C++中的类和对象是一种封装数据和行为的方式，可以将数据和行为组织成一个对象，更加方便地使用。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/622321539">模板：C++中的模板是一种通用编程技术，它允许程序员编写可适用于多种类型的代码，使得代码更加灵活。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/622322061">STL容器：C++标准库中提供了许多容器，如vector、map等，使得程序员可以更方便地操作数据结构。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/622525072">智能指针：C++中的智能指针可以自动管理动态内存，避免内存泄漏等问题，使得程序更加安全可靠。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/622527042">Lambda表达式：C++11中引入了Lambda表达式，可以方便地定义匿名函数，使得程序更加简洁和易读。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/622751429">constexpr：C++11中引入了constexpr关键字，可以在编译时计算出结果，使得程序更加高效。</a></li><li><a href="https://zhuanlan.zhihu.com/p/622758610">range-basedfor循环：C++11中引入了range-basedfor循环，可以方便地遍历容器中的元素，使得程序更加简洁和易读。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/623020512">模板元编程：C++中的模板元编程是一种高级编程技术，可以在编译期间进行计算和编程，从而提高程序的效率。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/623023472">const关键字：C++中的const关键字可以用于修饰变量、函数参数、函数返回值等，使得程序更加安全和可靠。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/623335955">static关键字：C++中的static关键字可以用于修饰类的成员变量和成员函数，使得这些成员可以在不创建对象的情况下被访问。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/623346345">friend关键字：C++中的friend关键字可以用于授权其他类或函数访问本类的私有成员，使得程序更加灵活和方便。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/623651234">namespace命名空间：C++中的namespace命名空间可以将相关的函数、变量、类等组织到一个命名空间中，使得程序更加清晰和易读。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/623652496">using关键字：C++中的using关键字可以用于定义别名、引入命名空间等，使得程序更加简洁和易读。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/624294266">explicit关键字：C++中的explicit关键字可以用于限制类型转换，使得程序更加安全和可靠。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/624294602">override关键字：C++11中引入了override关键字，可以用于重写父类的虚函数，使得程序更加清晰和易读。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/624613130">final关键字：C++11中引入了final关键字，可以用于禁止类的继承或函数的重写，使得程序更加严谨和可靠。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/624614590">thread_local关键字：C++11中引入了thread_local关键字，可以用于定义线程本地存储的变量，使得程序更加并发安全。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/624736356">move语义：C++11中引入了右值引用和move语义，可以有效地避免拷贝大对象的开销，提高程序的效率。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/624737461">noexcept关键字：C++11中引入了noexcept关键字，可以用于声明函数不会抛出异常，从而使得程序更加可靠。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/625814269">lambda表达式：C++11中引入了lambda表达式，可以方便地定义匿名函数，使得程序更加简洁和易读。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/625816113">nullptr关键字：C++11中引入了nullptr关键字，用于表示空指针，避免了空指针和整型之间的混淆。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/626138684">initializer_list：C++11中引入了initializer_list，可以方便地初始化容器和数组，使得程序更加简洁和易读。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/626139055">constexpr函数：C++11中引入了constexpr函数，可以在编译时计算出结果，使得程序更加高效。</a></li><li><a href="https://zhuanlan.zhihu.com/p/627132495">user-definedliterals：C++11中引入了user-definedliterals，可以定义自己的字面量类型，使得程序更加灵活。</a></li><li><a href="https://zhuanlan.zhihu.com/p/627132704">uniforminitialization：C++11中引入了uniforminitialization，可以使用统一的语法来初始化变量、容器、数组等，使得程序更加简洁和易读。</a></li><li><a href="https://zhuanlan.zhihu.com/p/627805328">range-basedfor循环：C++11中引入了range-basedfor循环，可以方便地遍历容器中的元素，使得程序更加简洁和易读。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/627806230">std::optional：C++17中引入了std::optional，用于表示可选的值，避免了使用空指针的问题，使得程序更加安全和可靠。</a></li><li><a href="https://zhuanlan.zhihu.com/p/628072846">ifconstexpr：C++17中引入了ifconstexpr语句，可以在编译时选择不同的代码分支，使得程序更加灵活和高效。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/628073888">std::variant：C++17中引入了std::variant，用于表示多个类型中的一个，使得程序更加灵活和易读</a>。</li><li><ahref="https://zhuanlan.zhihu.com/p/628815313">std::any：C++17中引入了std::any，用于表示任意类型的值，使得程序更加灵活和易读。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/628816339">std::string_view：C++17中引入了std::string_view，用于表示字符串的视图，避免了拷贝字符串的开销，提高了程序的效率。</a></li><li><a href="https://zhuanlan.zhihu.com/p/629300374">constexprif：C++17中引入了constexpr if语句，可以在编译时选择不同的代码分支，与ifconstexpr语句类似，但更加灵活和高效。</a></li><li><a href="https://zhuanlan.zhihu.com/p/629301256">structuredbindings：C++17中引入了structuredbindings，可以方便地将复杂的数据结构解构为多个变量，使得程序更加简洁和易读。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/629882710">inline变量：C++17中引入了inline变量，可以在头文件中定义变量，避免了多个编译单元之间的链接问题，使得程序更加灵活。</a></li><li><a href="https://zhuanlan.zhihu.com/p/629884213">constexprlambda：C++20中引入了constexprlambda，可以定义编译时计算的lambda表达式，使得程序更加高效和灵活。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/634064507">concepts：C++20中引入了concepts，可以定义泛型代码的约束条件，使得程序更加健壮和易读。</a></li><li><a href="https://zhuanlan.zhihu.com/p/641982152">spaceshipoperator：C++20中引入了spaceshipoperator，可以定义自定义类型之间的比较操作，使得程序更加灵活和易读。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/641982653">std::atomic_ref：C++20中引入了std::atomic_ref，用于对共享变量进行原子操作，可以避免使用原子变量的开销，提高程序的效率。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/644405655">coroutine：C++20中引入了coroutine，可以方便地实现协程，使得程序更加高效和灵活。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/644406625">std::span：C++20中引入了std::span，用于表示连续的内存空间，可以方便地操作数组和容器，提高了程序的效率。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/644683332">std::format：C++20中引入了std::format，用于格式化字符串，避免了使用printf的安全性问题，使得程序更加安全和易读。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/644683511">consteval函数：C++20中引入了consteval函数，可以在编译时计算出结果，与constexpr函数类似，但更加严格和高效。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/647174794">std::bit_cast：C++20中引入了std::bit_cast，用于进行类型间的位拷贝，避免了使用memcpy的安全性问题，使得程序更加安全和高效。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/647175128">requires表达式：C++20中引入了requires表达式，可以用于定义函数和类的约束条件，使得程序更加健壮和易读。</a></li><li>std::stop_token：C++20中引入了std::stop_token，用于取消异步操作，避免了使用回调函数的复杂性问题，使得程序更加简洁和易读。</li><li><ahref="https://zhuanlan.zhihu.com/p/648820972">std::synchronized：C++20中引入了std::synchronized，用于实现线程安全的操作，避免了使用锁的复杂性问题，使得程序更加灵活和易读。</a></li><li><ahref="https://zhuanlan.zhihu.com/p/648821861">co_await表达式：C++20中引入了co_await表达式，用于等待协程的完成，使得程序更加高效和灵活。</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python调试器工具--pdb</title>
    <link href="/2024/01/13/Python%E8%B0%83%E8%AF%95%E5%99%A8%E5%B7%A5%E5%85%B7-pdb/"/>
    <url>/2024/01/13/Python%E8%B0%83%E8%AF%95%E5%99%A8%E5%B7%A5%E5%85%B7-pdb/</url>
    
    <content type="html"><![CDATA[<h1 id="python调试器工具--pdb">Python调试器工具--pdb</h1><p><strong>pdb</strong> 是 python 自带的一个包，为 python程序提供了一种交互的源代码调试功能，主要特性包括设置断点、单步调试、进入函数调试、查看当前代码、查看栈片段、动态改变变量的值等。<strong>pdb</strong>有2种用法：</p><ul><li><strong>非侵入式方法</strong>（不用额外修改源代码，在命令行下直接运行就能调试）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 -m pdb filename.py<br></code></pre></td></tr></table></figure><ul><li><strong>侵入式方法</strong>（需要在被调试的代码中添加一行代码然后再正常运行代码）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python3">import pdb;pdb.set_trace()<br></code></pre></td></tr></table></figure><p>当你在命令行看到下面这个提示符时，说明已经正确打开了pdb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">(Pdb) <br></code></pre></td></tr></table></figure><p>然后就可以开始输入pdb命令了，下面是pdb的常用命令</p><h2 id="查看源代码">1.查看源代码</h2><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">l<br></code></pre></td></tr></table></figure><p>说明：</p><blockquote><p>查看当前位置前后11行源代码（多次会翻页）当前位置在代码中会用--&gt;这个符号标出来</p></blockquote><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ll<br></code></pre></td></tr></table></figure><p>说明：</p><blockquote><p>查看当前函数或框架的所有源代码</p></blockquote><h2 id="添加断点">2.添加断点</h2><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">b<br>b lineno<br>b filename:lineno<br><span class="hljs-comment"># b a.py:57  在a文件第57行加断点（57为报错位置）</span><br>b functionname<br></code></pre></td></tr></table></figure><p>参数：</p><blockquote><p>filename文件名，断点添加到哪个文件，<ahref="https://link.zhihu.com/?target=http%3A//xn--test-f96g.py/">如test.py</a>lineno断点添加到哪一行function：函数名，在该函数执行的第一行设置断点</p></blockquote><p>说明：</p><blockquote><p>1.不带参数表示查看断点设置 2.带参则在指定位置设置一个断点</p></blockquote><p><strong>侵入式添加断点举例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pdb<br>a = <span class="hljs-number">3</span><br>b = <span class="hljs-number">4</span><br>pdb.set_trace() <span class="hljs-comment"># insert breakpoint</span><br>a += <span class="hljs-number">1</span><br>b = b + a<br>pdb.set_trace() <span class="hljs-comment"># insert breakpoint</span><br></code></pre></td></tr></table></figure><p>py3.7后，支持直接添加breakpoint(),不需要进行import</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">3</span><br>b = <span class="hljs-number">4</span><br><span class="hljs-built_in">breakpoint</span>() <span class="hljs-comment"># insert breakpoint</span><br>a += <span class="hljs-number">1</span><br>b = b + a<br><span class="hljs-built_in">breakpoint</span>() <span class="hljs-comment"># insert breakpoint</span><br></code></pre></td></tr></table></figure><h2 id="添加临时断点">3.添加临时断点</h2><p>命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">tbreak<br>tbreak lineno<br>tbreak filename:lineno<br>tbreak functionname<br></code></pre></td></tr></table></figure><p>参数：</p><blockquote><p>同b</p></blockquote><p>说明：</p><blockquote><p>执行一次后时自动删除（这就是它被称为临时断点的原因）</p></blockquote><h2 id="清除断点">4.清除断点</h2><p>命令：</p><figure class="highlight pycon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pycon">cl<br>cl filename:lineno<br>cl bpnumber [bpnumber ...]<br></code></pre></td></tr></table></figure><p>参数：</p><blockquote><p>bpnumber 断点序号（多个以空格分隔）</p></blockquote><p>说明：</p><blockquote><p>1.不带参数用于清除所有断点，会提示确认（包括临时断点）2.带参数则清除指定文件行或当前文件指定序号的断点</p></blockquote><h2 id="打印变量值">5.打印变量值</h2><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">p expression  <span class="hljs-comment"># expression Python表达式</span><br>p tmp         <span class="hljs-comment"># 打印变量值</span><br></code></pre></td></tr></table></figure><h2 id="逐行调试命令">6.逐行调试命令</h2><p>包括 s ，n ， r 这3个相似的命令，区别在如何对待函数上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">s <span class="hljs-comment">#执行下一行（能够进入函数体）</span><br>n <span class="hljs-comment">#执行下一行（不会进入函数体）</span><br>r <span class="hljs-comment">#执行下一行（在函数中时会直接执行到函数返回处）</span><br></code></pre></td></tr></table></figure><h2 id="非逐行调试命令">7.非逐行调试命令</h2><p>命令1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">c <br></code></pre></td></tr></table></figure><p>说明：</p><blockquote><p>持续执行下去，直到遇到一个断点</p></blockquote><p>命令2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unt lineno<br></code></pre></td></tr></table></figure><p>说明：</p><blockquote><p>持续执行直到运行到指定行（或遇到断点）</p></blockquote><p>命令3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">j lineno<br></code></pre></td></tr></table></figure><p>说明：</p><blockquote><p>直接跳转到指定行（注意，被跳过的代码不执行）</p></blockquote><h2 id="查看函数参数">8.查看函数参数</h2><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">a<br></code></pre></td></tr></table></figure><p>说明：</p><blockquote><p>在函数中时打印函数的参数和参数的值</p></blockquote><h2 id="打印变量类型">9.打印变量类型</h2><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">whatis expression<br></code></pre></td></tr></table></figure><p>说明：</p><blockquote><p>打印表达式的类型，常用来打印变量值</p></blockquote><h2 id="启动交互式解释器">10.启动交互式解释器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">interact<br></code></pre></td></tr></table></figure><p>说明：</p><blockquote><p>启动一个python的交互式解释器，使用当前代码的全局命名空间（使用ctrl+d返回pdb）</p></blockquote><h2 id="打印堆栈信息">11.打印堆栈信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">w<br></code></pre></td></tr></table></figure><p>说明：</p><blockquote><p>打印堆栈信息，最新的帧在最底部。箭头表示当前帧。</p></blockquote><h2 id="退出pdb">12.退出pdb</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">q<br></code></pre></td></tr></table></figure><h2 id="速查表">13.速查表</h2><table><thead><tr class="header"><th>指令 (简写/全称)</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>b / break</td><td>设置断点</td></tr><tr class="even"><td>c / continual</td><td>继续执行程序</td></tr><tr class="odd"><td>n / next</td><td>执行下一行</td></tr><tr class="even"><td>l / list</td><td>查看当前代码段</td></tr><tr class="odd"><td>s / step</td><td>进入函数</td></tr><tr class="even"><td>r / return</td><td>执行代码指导从当前函数返回</td></tr><tr class="odd"><td>q / exit</td><td>中止并退出</td></tr><tr class="even"><td>pp</td><td>打印变量值</td></tr><tr class="odd"><td>help</td><td>帮助</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>调试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pdb</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器视觉测量与建模</title>
    <link href="/2024/01/07/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E6%B5%8B%E9%87%8F%E4%B8%8E%E5%BB%BA%E6%A8%A1/"/>
    <url>/2024/01/07/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E6%B5%8B%E9%87%8F%E4%B8%8E%E5%BB%BA%E6%A8%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="机器视觉测量与建模">机器视觉测量与建模</h1><h2 id="机器视觉的发展">1.机器视觉的发展</h2><h3 id="三维测量与建模的应用举例">1.1 三维测量与建模的应用举例</h3><h3 id="视觉处理种的挑战问题">1.2 视觉处理种的挑战问题</h3><h2 id="图像处理的基础">2.图像处理的基础</h2><h3 id="图像的感知与获取">2.1 图像的感知与获取</h3><h3 id="坐标转换基础">2.2 坐标转换基础</h3><h3 id="透视投影的相机模型">2.3 透视投影的相机模型</h3><h3 id="射影几何基础">2.4 射影几何基础</h3><h2 id="特征提取与匹配">3.特征提取与匹配</h2><h3 id="相机标定的基本概念">3.1 相机标定的基本概念</h3><p>相机标定有多种含义，包括辐射定标、颜色校正、几何校准、噪声校准、透镜的像差标准等。本文涉及的主要是几何标定。</p><h3 id="直接线性变换法标定">3.2 直接线性变换法标定</h3><h3 id="棋盘格相机标定方法">3.3 棋盘格相机标定方法</h3><h3 id="基于灭点平行线消失点相机标定方法">3.4基于灭点(平行线消失点)相机标定方法</h3><h4 id="基于灭点平行线消失点相机标定方法概述">3.4.1基于灭点(平行线消失点)相机标定方法概述</h4><ul><li>灭点的定义</li></ul><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20240107022139498.png"alt="image-20240107022139498" /><figcaption aria-hidden="true">image-20240107022139498</figcaption></figure><ul><li>灭点有三种</li></ul><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20240107022213078.png"alt="image-20240107022213078" /><figcaption aria-hidden="true">image-20240107022213078</figcaption></figure><ul><li>通过灭点的正交方向确定<strong>绝对圆锥曲线</strong> <spanclass="math inline">\(IACω\)</span>,标内参</li></ul><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20240107022624283.png"alt="image-20240107022624283" /><figcaption aria-hidden="true">image-20240107022624283</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20240107022921135.png"alt="image-20240107022921135" /><figcaption aria-hidden="true">image-20240107022921135</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20240107023451654.png"alt="image-20240107023451654" /><figcaption aria-hidden="true">image-20240107023451654</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20240107041321631.png"alt="image-20240107041321631" /><figcaption aria-hidden="true">image-20240107041321631</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20240107041455296.png"alt="image-20240107041455296" /><figcaption aria-hidden="true">image-20240107041455296</figcaption></figure><h4 id="基于代数和几何方法的单张图像线性标定分析和实现">3.4.2基于代数和几何方法的单张图像线性标定分析和实现</h4><p>已知单张具有3条正交消失线的场景图像（或者至少有2条正交线，此时假设主点为图像中心），则可直接估算相机内参，另外如果已知场景图像中某些物体的实际尺寸或者坐标，则还可估计相机外参旋转矩阵<span class="math inline">\(R\)</span> ，相机外参平移向量 <spanclass="math inline">\(T\)</span> 。</p><p>在基于3个消失点坐标计算已知的情况下，可以分别通过计算相机内参 <spanclass="math inline">\(K\)</span> 、外参 <spanclass="math inline">\(R\)</span> 、 <spanclass="math inline">\(T\)</span> 这三个步骤逐渐恢复相机位姿。其中 <spanclass="math inline">\(K\)</span> 需具有焦距 <spanclass="math inline">\(f\)</span> ，主点 <spanclass="math inline">\(\left(u_0 ,v_0 \right)\)</span>三个独立未知变量。</p><h5 id="计算相机内参k">计算相机内参K</h5><ul><li>代数方法：</li></ul><p>单张图像场景中，三个正交的消失线方向向量 <spanclass="math inline">\(e_1 =\left\lbrack \begin{array}{c} 1\\ 0\\ 0\end{array}\right\rbrack ,e_2 =\left\lbrack \begin{array}{c} 0\\ 1\\ 0\end{array}\right\rbrack ,e_3 =\left\lbrack \begin{array}{c} 0\\ 0\\ 1\end{array}\right\rbrack\)</span> ， 满足投影公式</p><p><span class="math inline">\(\lambda_i \left\lbrack \begin{array}{c}x\\ 1 \end{array}\right\rbrack =K*\left\lbrack R,t\right\rbrack*\left\lbrack \begin{array}{c} e_i \\ 0\end{array}\right\rbrack\)</span> , (1)</p><p>注意位于无限远处的消失点齐次坐标是 <spanclass="math inline">\(\left\lbrack \begin{array}{c} e_i \\ 0\end{array}\right\rbrack\)</span> .整理上式，得：</p><p><span class="math inline">\(e_i =\lambda_i R^T K^{-1} \left\lbrack\begin{array}{c} x\\ 1 \end{array}\right\rbrack\)</span> ， (2)</p><p>又由正交性约束,有 <span class="math inline">\({e_i }^T e_j=0\)</span> ,得：</p><p>​ (3)</p><p>K的求解通过(3)求解，实现为calIntrinsicFrom3VanishingPts.m函数。</p><ul><li><p>几何方法：</p><p><img src="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/triPlot2.jpg" alt="triPlot2" style="zoom: 50%;" /></p></li></ul><p>四面体PABC为直角四面体（顶点P为互相垂直的三条棱线经过），底面三角形ABC为像平面，A,B,C为图像平面的三个消失点坐标，其中z值为<span class="math inline">\(f\)</span>，P点为相机光心，P点到底面ABC的距离为焦距 <spanclass="math inline">\(f\)</span>，垂足为底面三角形ABC的垂心，垂心坐标为相机主点 <spanclass="math inline">\(O_c \left(u_0 ,v_0 \right)\)</span> .</p><h5 id="计算外参旋转矩阵r">计算外参旋转矩阵R</h5><ul><li>代数方法：</li></ul><p>由</p><p><span class="math inline">\(\lambda_i {\left\lbrack \begin{array}{c}x_1 \\ x_2 \\ 1 \end{array}\right\rbrack }_i ={K*R*e}_i\)</span> ,(4)</p><p>两边左乘 <span class="math inline">\(K^{-1}\)</span> ，</p><p><span class="math inline">\(\lambda_i K^{-1} {\left\lbrack\begin{array}{c} x_1 \\ x_2 \\ 1 \end{array}\right\rbrack }_i={R*e}_i\)</span> , (5)</p><p>注意： <span class="math inline">\({R*e}_1 =\left\lbrack r_{1,} r_2,r_3 \right\rbrack \left\lbrack \begin{array}{c} 1\\ 0\\ 0\end{array}\right\rbrack =r_1\)</span> ,得：</p><p><span class="math inline">\({r_i =\lambda }_i K^{-1} {\left\lbrack\begin{array}{c} x_1 \\ x_2 \\ 1 \end{array}\right\rbrack }_i\)</span>，(其中 <span class="math inline">\(\lambda_i\)</span> 可以通过 <spanclass="math inline">\(\left\|r_i \right\|=1\)</span> 约束求解，这里<span class="math inline">\(r_i\)</span> 为外参旋转矩阵的第 <spanclass="math inline">\(i\)</span> 列)</p><ul><li>几何方法：</li></ul><p><span class="math inline">\(r_i =\frac{\vec{P{\mathrm{V}}_i }}{\left\|\vec{P{\mathrm{V}}_i } \right\|}\)</span> ，(其中 <spanclass="math inline">\({\mathrm{V}}_i\)</span> 为消失点， <spanclass="math inline">\(\vec{P{\mathrm{V}}_i }\)</span>为相机光心到像平面消失点的三维方向矢量也即空间消失线的三维方向矢量！)</p><h5 id="计算外参平移向量t">计算外参平移向量T</h5><ul><li>代数方法：</li></ul><p>这里边计算边分析推导：</p><p><span class="math display">\[ \lambda_i {\left\lbrack\begin{array}{c} x\\ 1 \end{array}\right\rbrack } =K*\left\lbrackR,t\right\rbrack *{\left\lbrack \begin{array}{c} X\\ 1\end{array}\right\rbrack }_i \]</span></p><p>展开，写成标量形式，即 <span class="math inline">\(\lambda_i\left\lbrack \begin{array}{c} x_1 \\ x_2 \\ 1 \end{array}\right\rbrack=\left\lbrack \begin{array}{ccc} f &amp; 0 &amp; u_0 \\ 0 &amp; f &amp;v_0 \\ 0 &amp; 0 &amp; 1 \end{array}\right\rbrack *\left\lbrack\begin{array}{cccc} R_{11}  &amp; R_{12}  &amp; R_{13}  &amp; t_1 \\R_{21}  &amp; R_{22}  &amp; R_{23}  &amp; t_2 \\ R_{31}  &amp;R_{32}  &amp; R_{33}  &amp; t_3  \end{array}\right\rbrack *\left\lbrack\begin{array}{c} X_1 \\ X_2 \\ X_3 \\ 1\end{array}\right\rbrack\)</span></p><p>其中内参矩阵 <span class="math inline">\(K\)</span> ： <spanclass="math inline">\(K=\displaystyle \left(\begin{array}{ccc} f &amp; 0&amp; u_0 \\ 0 &amp; f &amp; v_0 \\ 0 &amp; 0 &amp; 1\end{array}\right)\)</span></p><p>外参旋转矩阵 <span class="math inline">\(R\)</span> ：</p><p><span class="math inline">\(R =\displaystyle \left(\begin{array}{ccc}R_{1,1}  &amp; R_{1,2}  &amp; R_{1,3} \\ R_{2,1}  &amp; R_{2,2}  &amp;R_{2,3} \\ R_{3,1}  &amp; R_{3,2}  &amp;R_{3,3}  \end{array}\right)\)</span></p><p>外参平移向量 <span class="math inline">\(t\)</span> ：</p><p><span class="math inline">\(t =\displaystyle \left(\begin{array}{c}t_1 \\ t_2 \\ t_3  \end{array}\right)\)</span></p><p>世界坐标点 <span class="math inline">\(X\)</span> ：</p><p><span class="math inline">\(X =\displaystyle \left(\begin{array}{c}X_1 \\ X_2 \\ X_3  \end{array}\right)\)</span></p><p>像点坐标 <span class="math inline">\(x\)</span> ： <spanclass="math inline">\(x =\displaystyle \left(\begin{array}{c} x_1 \\x_2  \end{array}\right)\)</span></p><p><span class="math inline">\(express1 =\displaystyle\left(\begin{array}{c} f\,t_1 +t_3 \,u_0 +X_1 \,{\left(R_{1,1}\,f+R_{3,1} \,u_0 \right)}+X_2 \,{\left(R_{1,2} \,f+R_{3,2} \,u_0\right)}+X_3 \,{\left(R_{1,3} \,f+R_{3,3} \,u_0 \right)}\\ f\,t_2 +t_3\,v_0 +X_1 \,{\left(R_{2,1} \,f+R_{3,1} \,v_0 \right)}+X_2\,{\left(R_{2,2} \,f+R_{3,2} \,v_0 \right)}+X_3 \,{\left(R_{2,3}\,f+R_{3,3} \,v_0 \right)}\\ t_3 +R_{3,1} \,X_1 +R_{3,2} \,X_2 +R_{3,3}\,X_3  \end{array}\right)\)</span></p><p><span class="math inline">\(express2 =\displaystyle \begin{array}{l}\left(\begin{array}{c} \frac{f\,t_1 +t_3 \,u_0 +X_1 \,{\left(R_{1,1}\,f+R_{3,1} \,u_0 \right)}+X_2 \,{\left(R_{1,2} \,f+R_{3,2} \,u_0\right)}+X_3 \,{\left(R_{1,3} \,f+R_{3,3} \,u_0 \right)}}{\sigma_1 }-x_1\\ \frac{f\,t_2 +t_3 \,v_0 +X_1 \,{\left(R_{2,1} \,f+R_{3,1} \,v_0\right)}+X_2 \,{\left(R_{2,2} \,f+R_{3,2} \,v_0 \right)}+X_3\,{\left(R_{2,3} \,f+R_{3,3} \,v_0 \right)}}{\sigma_1}-x_2  \end{array}\right)\\\mathrm{}\,\\{where}\\\sigma_1 =t_3 +R_{3,1}\,X_1 +R_{3,2} \,X_2 +R_{3,3} \,X_3 \end{array}\)</span></p><p>把 <span class="math inline">\(t_1 ,t_2 ,t_3\)</span>从上述公式独立出来，令express2=0，重新整理可得到下式：</p><p><span class="math inline">\(\left\lbrack \begin{array}{ccc} f &amp; 0&amp; u_0 -x_1 \\ 0 &amp; f &amp; v_0 -x_2  \end{array}\right\rbrack\left\lbrack \begin{array}{c} t_1 \\ t_2 \\t_3  \end{array}\right\rbrack =\left\lbrack \begin{array}{c} x_1\left(R_{3,1} X_1 +R_{3,2} X_2 +R_{3,3} X_3 \right)-X_1 \left(R_{1,1}f+R_{3,1} u_0 \right)-X_2 \left(R_{1,2} f+R_{3,2} u_0 \right)-X_3\left(R_{1,3} f+R_{3,3} u_0 \right)\\ x_2 \left(R_{3,1} X_1 +R_{3,2} X_2+R_{3,3} X_3 \right)-X_1 \left(R_{2,1} f+R_{3,1} v_0 \right)-X_2\left(R_{2,2} f+R_{3,2} v_0 \right)-X_3 \left(R_{2,3} f+R_{3,3} v_0\right) \end{array}\right\rbrack\)</span> (6a)</p><p>为便于从形式上公式简化，把上式写成如下形式：</p><p><span class="math inline">\(\left\lbrack \begin{array}{ccc} f &amp; 0&amp; u_0 -x_1 \\ 0 &amp; f &amp; v_0 -x_2  \end{array}\right\rbrack\left\lbrack \begin{array}{c} t_1 \\ t_2 \\t_3  \end{array}\right\rbrack =\left\lbrack \begin{array}{c} r_3 P_w\left(x_1 -u_0 \right)-f\left(r_1 P_w \right)\\ r_3 P_w \left(x_2 -v_0\right)-f\left(r_2 P_w \right) \end{array}\right\rbrack\)</span> ，(6b)</p><p>其中： <span class="math inline">\(r_i =\left\lbrack R_{i,1} ,R_{i,2},R_{i,3} \right\rbrack ,P_w =\left\lbrack \begin{array}{c} X_1 \\ X_2 \\X_3  \end{array}\right\rbrack\)</span>,其余都为标量值。工程上计算直接使用(6a)式，svd求解即可。</p><ul><li>几何方法：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/cameraProject1.jpg" alt="Fig1.实际立体图（相机像素坐标系下）" style="zoom: 25%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/cameraProject3.jpg" alt="Fig2.实际立体成像图（相机像素坐标)" style="zoom: 50%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/birdView3.jpg" alt="Fig3.实际俯视图（相机像素坐标系下）" style="zoom: 25%;" /></p><p><strong>数学背景</strong>：已知空间中三角形 <spanclass="math inline">\(\bigtriangleup \textrm{PMN}\)</span>的三个顶点坐标分别为 <span class="math inline">\(P\left(x_0 ,y_0 ,z_0\right),M\left(x_1 ,y_1 ,z_1 \right),N\left(x_2 ,y_2 ,z_2\right)\)</span> ，该三角形所在平面为 <spanclass="math inline">\(\psi\)</span> ，位于该平面内过一顶点P的方向向量为<span class="math inline">\(l=\left(l_1 ,l_2 ,l_3 \right)\)</span>，该向量不与此三角形任何边平行/重合，则过点M且平行于方向向量 <spanclass="math inline">\(l\)</span> 的直线 <spanclass="math inline">\(\textrm{MQ}\)</span> 必与 <spanclass="math inline">\(\textrm{PN}\)</span> 所在直线相交，交点为 <spanclass="math inline">\(Q\left(x,y,z\right)\)</span>，其示意图和解析解如下：</p><p><img src="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/mathD.jpg" alt="Fig4.求解Q点示意图" style="zoom:25%;" /></p><p>由已知平行性条件，可得下面共面的两条空间直线方程组：</p><p><span class="math display">\[ \left\lbrace \begin{array}{ll}\frac{x-x_1 }{l_1 }=\frac{y-y_1 }{l_2 }=\frac{z-z_1 }{l_3 } &amp; \\\frac{x-x_2 }{x_2 -x_0 }=\frac{x-x_2 }{y_2 -y_0 }=\frac{x-x_2 }{z_2 -z_0} &amp;  \end{array}\right. \]</span></p><p><span class="math inline">\(Q = \displaystyle \begin{array}{l}\left(\begin{array}{ccc} \sigma_1  &amp; \frac{l_2 \,x_1 \,y_0 +l_2\,x_0 \,y_2 -l_2 \,x_2 \,y_0 -l_2 \,x_1 \,y_2 -l_1 \,y_0 \,y_1 +l_1\,y_1 \,y_2 }{l_2 \,x_0 -l_2 \,x_2 -l_1 \,y_0 +l_1 \,y_2 } &amp; z_1-\frac{l_3 \,{\left(x_1 -\sigma_1 \right)}}{l_1 }\end{array}\right)\\\mathrm{}\\\textrm{where}\\\mathrm{}\\\;\;\sigma_1=\frac{l_2 \,x_0 \,x_1 -l_2 \,x_1 \,x_2 -l_1 \,x_0 \,y_1 +l_1 \,x_0\,y_2 -l_1 \,x_2 \,y_0 +l_1 \,x_2 \,y_1 }{l_2 \,x_0 -l_2 \,x_2 -l_1\,y_0 +l_1 \,y_2 }\end{array}\)</span></p><p>实现函数为calQcoord.m。</p><p>主要利用相似三角形计算，由Fig2中成像过程，可知 <spanclass="math inline">\(\bigtriangleup \textrm{PMQ}\sim \bigtriangleup{\textrm{PM}}_w N_w\)</span> ，点 <spanclass="math inline">\(M_w\)</span> 、 <spanclass="math inline">\(N_w\)</span> 分别为图像中 <spanclass="math inline">\(M\)</span> 、 <spanclass="math inline">\(N\)</span>点对应世界坐标系中的点，因在世界坐标系中 <spanclass="math inline">\(\left\|\textrm{MN}\right\|\)</span>模已知，故可求解 <span class="math inline">\(M\)</span>点的深度，从而推出外参 <span class="math inline">\(T\)</span>，详细见demoOneImgCalibrate.m实现。</p><p>参考：</p><ol type="1"><li><ahref="https://github.com/cuixing158/singleImageCalibration/blob/main/calIntrinsicGeometricAnalysis.md#利用直角四面体性质求解（推荐）">基于几何方法的单张图像标定之相机内参数学分析</a></li><li><ahref="https://github.com/cuixing158/singleImageCalibration/blob/main/calExtrinsicAnalysis.md#计算相机内参k">基于代数和几何方法的单张图像线性标定分析和实现</a></li></ol><h3 id="基于光束平差法的外参标定方法">3.5基于光束平差法的外参标定方法</h3><p>为了求解相机的位姿(R,t)和空间三维点的3D坐标，常采用优化的方式，优化方法中常用的是光束平差法（BA，又叫捆绑调整，束调整等）。BA方法的核心是最小化重投影误差，即有一个图像中的2D点m，算得一个三维点初始的3D坐标P时，将三维点重新投影到图像平面得到m'，最小化原始图像点m与重投影回去的m'之间（所有图像所有对应的图像点）的误差。可以看出，最小化投影误差，是一个非线性最小二乘问题。非线性最小二乘问题求解，常采用的方法是线性化，即使用泰勒展开式展开，忽略高阶项，变成线性最小二乘问题。</p><h3 id="摄像机和激光雷达的联合标定">3.6 摄像机和激光雷达的联合标定</h3><h3 id="其他标定方法">3.7 其他标定方法</h3><h2 id="特征提取与匹配-1">4.特征提取与匹配</h2><h3 id="图像梯度信息">4.1 图像梯度信息</h3><h3 id="特征点提取">4.2 特征点提取</h3><h3 id="特征匹配">4.3 特征匹配</h3><h2 id="由运动恢复结构sfm">5.由运动恢复结构SFM</h2><h3 id="对极几何">5.1 对极几何</h3><h3 id="二视图重建">5.2 二视图重建</h3><h3 id="光束法平差">5.3 光束法平差</h3><h2 id="双目立体视觉">6.双目立体视觉</h2><h3 id="双目视觉系统介绍">6.1 双目视觉系统介绍</h3><h3 id="密集匹配">6.2 密集匹配</h3><h3 id="结构光三维成像">6.3 结构光三维成像</h3><h2 id="三维点云滤波与表面建模">7.三维点云滤波与表面建模</h2><h3 id="三维点云的基本特征">7.1 三维点云的基本特征</h3><h3 id="点云数据空间结构增强">7.2 点云数据空间结构增强</h3><h3 id="表面建模概念和方法">7.3 表面建模概念和方法</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Cpp调试-GDB的安装与使用</title>
    <link href="/2024/01/04/Cpp%E8%B0%83%E8%AF%95-GDB%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/01/04/Cpp%E8%B0%83%E8%AF%95-GDB%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基于单目视觉的三维重建</title>
    <link href="/2024/01/04/%E5%9F%BA%E4%BA%8E%E5%8D%95%E7%9B%AE%E8%A7%86%E8%A7%89%E7%9A%84%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA/"/>
    <url>/2024/01/04/%E5%9F%BA%E4%BA%8E%E5%8D%95%E7%9B%AE%E8%A7%86%E8%A7%89%E7%9A%84%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基于车道线的道路标定</title>
    <link href="/2023/12/26/%E5%9F%BA%E4%BA%8E%E8%BD%A6%E9%81%93%E7%BA%BF%E7%9A%84%E9%81%93%E8%B7%AF%E6%A0%87%E5%AE%9A/"/>
    <url>/2023/12/26/%E5%9F%BA%E4%BA%8E%E8%BD%A6%E9%81%93%E7%BA%BF%E7%9A%84%E9%81%93%E8%B7%AF%E6%A0%87%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1id="基于车道线的cam2vehicle道路标定">基于车道线的Cam2vehicle道路标定</h1><p>1.pitch角的标定：基于假设，车道线线平行，车体和路面平行（车子没有抖动），车道线像素投影到地面为平行的3D点。</p><ul><li><em>怎么判断车子当前是平稳的状态？</em></li></ul><p>优化标量：pitch</p><p>目标函数：车道线地面投影3D点平行。（车道线地面投影的夹角。优化目标夹角为0）</p><p><strong>优化</strong>过程：修改pitch-&gt;R矩阵-&gt;引入鱼眼原图-&gt;3D-&gt;平行判断</p><p>2.roll角度：车道线等宽、灯杆垂直地面（或者有第三方车道线真值提供）；</p><ul><li><em>怎么准确检测车道线的边缘</em></li><li><em>怎么检测灯杆轴线</em></li></ul><p>3.yaw:多帧判断车子直行，计算车道线投影点和X方向夹角</p><p>多帧<strong>优化</strong>yaw角，使得所有点在一条直线上；</p><p>通过标志牌测距，优化yaw角，结合单目中用内参计算标志牌的距离。结合里程计，标志牌在的x方向的位移等于行进里程。</p><ul><li><em>怎么结合单目中用内参计算标志牌的距离</em></li></ul><p>参考</p><p><ahref="https://cloud.tencent.com/developer/article/1673568">算法集锦（18）| 自动驾驶 | 车道线检测算法-腾讯云开发者社区-腾讯云(tencent.com)</a></p><p>在HSV空间隔离车道线，效果很糟糕，白色车道线和灰暗地面无法分辨、</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20231226193154167.png"alt="使用HSV隔离车道线" /><figcaption aria-hidden="true">使用HSV隔离车道线</figcaption></figure><p>在HSL颜色空间处理。由于车道线通常为黄、白二色，所以设置黄白阈值对车道线进行处理。受到相机ISP以及实际场景路面的粗糙度、污渍、灰尘以及车道线的破损程度印象影响，仍然无法得到一组泛化能力较高得阈值。</p><p>下图使用hsl空间的黄白阈值对图像进行筛选后再融合，融合后进行灰度化处理。由于融合图像中有大量0值黑块，0值黑块影响了二值化自适应阈值的计算，因此在进行二值化阈值计算的过程中应尽量排除黑色区域的影响。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20240104103145360.png"alt="hsl空间筛选黄白车道线后进行二值化处理" /><figcaptionaria-hidden="true">hsl空间筛选黄白车道线后进行二值化处理</figcaption></figure><p>选择HSV色域范围的时候可以参考下面表格：</p><figure><imgsrc="https://github.com/BIGBIGBrotherAI/BlogImg/blob/main/1404363-20220104143029277-2130379274.png?raw=true"alt="1404363-20220104143029277-2130379274.png" /><figcaptionaria-hidden="true">1404363-20220104143029277-2130379274.png</figcaption></figure><p>opencv中的 H分量是 0~180， S分量是0~255，V分量是0～255，但是HSV颜色空间却规定的是，H范围0～360，S范围0～1，V范围0～1，所以你需要自己转换一下，H*2，V/255，S/255。</p><p><img src="https://github.com/BIGBIGBrotherAI/BlogImg/blob/main/1404363-20230201110616996-251674494.jpg?raw=true" alt="1404363-20230201110616996-251674494.jpg" style="zoom:50%;" /></p><p><strong>H—Hue</strong>即色相，就是我们平时所说的红、绿，如果你分的更细的话可能还会有洋红、草绿等等；在HSV模型中，用度数来描述色相，其中红色对应0度，绿色对应120度，蓝色对应240度。</p><p>S——Saturation即饱和度，色彩的深浅度(0-100%)，对于一种颜色比如红色，我们可以用浅红——大红——深红——红得发紫等等语言来描述它（请原谅一个纯理科生的匮乏的颜色系统），对应在画水彩的时候即一种颜料加上不同分量的水形成不同的饱和度。V——Value即色调，纯度，色彩的亮度(0-100%)，这个在调整屏幕亮度的时候比较常见。</p><p>注：在模型2中：</p><blockquote><p>H是色彩点在对应圆形切面上与红色半径(对于H=0度)所形成的圆心角。V是色彩点所在圆形切面到圆锥顶点的距离。在顶面上V=1 顶点V=0。S是色彩点到所在圆形切面圆心的距离与该圆半径的比例值，在圆锥表面上S=1，在圆心处S=0。</p></blockquote><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/1404363-20230201110638475-2037627953.jpg"alt="1404363-20230201110638475-2037627953" /><figcaptionaria-hidden="true">1404363-20230201110638475-2037627953</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>自动驾驶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>在线标定</tag>
      
      <tag>环视相机</tag>
      
      <tag>车道线检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git CI/CD搭建自动化编译</title>
    <link href="/2023/12/18/Git-CI-CD%E6%90%AD%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E5%B9%B3%E5%8F%B0/"/>
    <url>/2023/12/18/Git-CI-CD%E6%90%AD%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在大型的开源项目或者软件开发过程中，很多开发者都会去提交<code>PR</code>或者进行代码的<code>push</code>操作。如果对于每次代码合并都需要项目的核心维护者进行<code>code review</code>，这项工作是及其困难而且耗时的。因此许多团队都会指定一套代码规范,然后编写测试用例严格的检查每次代码修改，这样能够非常有效的减少后期代码维护的成本。</p><p>现在，基于<strong>githubaction</strong>, 我们可以自动化的完成代码的<code>CI/CD</code> 工作流。­<strong>Githubaction</strong>是 GitHub推出的持续集成 (Con­tin­u­ous in­te­gra­tion，简称 CI)服务，它提供了配置非常不错的虚拟服务器环境，基于它可以进行构建、测试、打包、部署项目。</p><p>Github Actions 的最大优势就是它是与 GitHub高度整合的，只需一个配置文件即可自动开启服务。甚至你不需要购买服务器 ——GitHub Actions自带云环境运行，包括私有仓库也可以享用，而且云环境性能也非常不错。</p><p>本篇文章将介绍 GitHub Ac­tions 的基本使用方法。</p><h3 id="ci-continuous-integration">CI (Continuous integration)</h3><p>互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuousintegration，简称CI）</p><h4 id="概念">概念</h4><p>持续集成指的是，频繁地（一天多次）将代码集成到主干。它的好处主要有两个</p><ul><li>快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。</li><li>防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。</li></ul><p>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p><h4 id="持续交付">持续交付</h4><p>持续交付（Continuousdelivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。</p><h4 id="持续部署">持续部署</h4><p>持续部署（continuousdeployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。</p><p>持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。</p><h4 id="流程">流程</h4><p>根据持续集成的设计，代码从提交到生产，整个过程有以下几步。</p><p>（1）提交</p><p>流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交（commit）。</p><p>（2）测试（第一轮）</p><p>代码仓库对commit操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。测试有好几种。</p><ul><li>单元测试：针对函数或模块的测试</li><li>集成测试：针对整体产品的某个功能的测试，又称功能测试</li><li>端对端测试：从用户界面直达数据库的全链路测试</li></ul><ol start="3" type="1"><li>构建</li></ol><p>通过第一轮测试，代码就可以合并进主干，就算可以交付了。交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。常用的构建工具如下。</p><ul><li>Jenkins</li><li>Travis</li><li>Codeship</li><li>Strider</li></ul><ol start="4" type="1"><li>测试（第二轮）</li></ol><p>构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。</p><p>第二轮是全面测试，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。</p><p>需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。</p><ol start="5" type="1"><li>部署</li></ol><p>通过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（tar filename.tar * ）存档，发到生产服务器。</p><ol start="6" type="1"><li>回滚</li></ol><p>一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>项目工程管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用Git操作</title>
    <link href="/2023/12/18/%E5%B8%B8%E7%94%A8Git%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/12/18/%E5%B8%B8%E7%94%A8Git%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="常用git-操作">常用Git 操作</h2><h3 id="git-强制回退删除已提交慎用">1.Git强制回退，删除已提交（<strong><em>慎用</em></strong>）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git reset --hard commit_id<br>git push --force origin 3dod<br></code></pre></td></tr></table></figure><h3 id="git-本地仓库关联远程仓库">2.git 本地仓库关联远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git remote <span class="hljs-comment"># 查看当前有哪些远程仓库</span><br>git remote -v <span class="hljs-comment"># 列出当前仓库中已配置的远程仓库，并显示它们的 URL</span><br>git remote add &lt;本地仓库名&gt; &lt;远程仓库url&gt;  <span class="hljs-comment"># 本地仓库关联远程仓库</span><br>git remote <span class="hljs-built_in">rm</span>  &lt;远程仓库别名&gt;  <span class="hljs-comment"># 删除远程仓库</span><br></code></pre></td></tr></table></figure><h3 id="git分支操作">3.Git分支操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git branch                  <span class="hljs-comment"># 查看本地分支</span><br>git branch -r               <span class="hljs-comment"># 查看远程分支</span><br>git branch  (branchname)     <span class="hljs-comment"># 创建新分支(branchname) </span><br>git checkout -b (branchname) <span class="hljs-comment"># 创建新分支并(branchname) 立即切换到该分支</span><br>git checkout (branchname)   <span class="hljs-comment"># 可以切换到分支(branchname) </span><br>git branch -d (branchname)  <span class="hljs-comment"># 可以删除分支(branchname) </span><br></code></pre></td></tr></table></figure><h3 id="git-本地仓库添加暂存文件">4.Git 本地仓库添加暂存文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git add &lt;文件1&gt; &lt;文件1&gt; &lt;文件2&gt; &lt;文件3&gt; ...<br></code></pre></td></tr></table></figure><h3 id="git-命令来查看相关文件的状态查看更新的详细信息">5.Git命令来查看相关文件的状态/查看更新的详细信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git status   <span class="hljs-comment"># 查看相关文件的状态</span><br>git diff     <span class="hljs-comment"># 查看尚未缓存的改动更新的详细信息</span><br>git diff --cached  <span class="hljs-comment"># 查看已缓存的改动： </span><br>git diff HEAD      <span class="hljs-comment"># 查看已缓存的与未缓存的所有改动：</span><br>git diff --<span class="hljs-built_in">stat</span>    <span class="hljs-comment"># 显示摘要而非整个 diff</span><br></code></pre></td></tr></table></figure><h3 id="git-取消已缓存的内容">6.Git 取消已缓存的内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git reset HEAD test.txt   <span class="hljs-comment"># 用于取消已缓存的内容，如我们要取消已提交的test.txt文件.执行完之后，再使用commit提交时，test.txt文件不会被提交。</span><br></code></pre></td></tr></table></figure><h3 id="git-提交暂存文件">7.Git 提交暂存文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git commit -m <span class="hljs-string">&quot;&lt;提交说明&gt;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="git-提交修改到远程仓库">8.Git 提交修改到远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git push &lt;本地仓库名&gt; &lt;远程分支名&gt;<br></code></pre></td></tr></table></figure><h3 id="git-拉取远程仓库">9.Git 拉取远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git pull  <span class="hljs-comment">#相当于是从远程获取最新版本并merge到本地</span><br>git fetch  <span class="hljs-comment"># 相当于是从远程获取最新版本到本地，不会自动合并。</span><br></code></pre></td></tr></table></figure><h3 id="git合并操作">10.Git合并操作</h3><p>合并的时候，最大的难点就是冲突了，合并并不仅仅是简单的文件添加、移除的操作，Git也会合并修改，如果我们在两个分支中同时修改了同一个文件，这时再合并，就可能会产生冲突，冲突并不可怕，可怕的是要怎样去解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git merge branchname <span class="hljs-comment">#将任意分支合并到到当前分支中</span><br></code></pre></td></tr></table></figure><h3 id="git查看提交历史">11.Git查看提交历史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git <span class="hljs-built_in">log</span> <span class="hljs-comment"># 命令查看</span><br>git –oneline <span class="hljs-comment"># 查看历史记录的简洁版本</span><br>git –graph <span class="hljs-comment"># 查看历史中什么时候出现了分支、合并</span><br>git –reverse <span class="hljs-comment"># 逆向显示所有日志</span><br>git –author <span class="hljs-comment"># 查找指定用户的提交日志</span><br>git –since、–before、 --<span class="hljs-keyword">until</span>、–after <span class="hljs-comment"># 指定筛选日期</span><br>git –no-merges <span class="hljs-comment"># 选项以隐藏合并提交</span><br>git <span class="hljs-built_in">log</span> --autho <span class="hljs-comment"># 查找指定用户的提交日志</span><br></code></pre></td></tr></table></figure><h3 id="git-标签操作">12.Git 标签操作</h3><p>使用标签可以很方便的永远的记住那个特别的提交快照，比如：我们发一个新的版本时，可以给它加一个“vx.x”版本，这样你可以使用gittag给它打上标签。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git tag -a v1.0 <span class="hljs-comment"># 创建一个带注解的标签,可以很方便的永远的记住那个特别的提交快照</span><br>git tag <span class="hljs-comment"># 查看标签</span><br>git tag -a &lt;tagname&gt; -m <span class="hljs-string">&quot;某某标签&quot;</span> <span class="hljs-comment">#指定标签信息</span><br>git tag -a v1.0 d6f7147 <span class="hljs-comment"># d6f7147提交已发布，可对其追加标签 </span><br>git checkout tag_name <span class="hljs-comment"># 但是，这时候 git 可能会提示你当前处于一个“detached HEAD&quot; 状态。因为 tag 相当于是一个快照，是不能更改它的代码的。如果要在 tag 代码的基础上做修改，你需要一个分支： git checkout -b branch_name tag_name</span><br></code></pre></td></tr></table></figure><h3 id="git-本地暂存">13.Git 本地暂存</h3><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/git_stash%E5%B7%A5%E4%BD%9C%E6%A0%91.jpg"alt="git_stash工作树" /><figcaption aria-hidden="true">git_stash工作树</figcaption></figure><p><strong>开发到一半,同步远端代码</strong>：当你的开发进行到一半,但是代码还不想进行提交,然后需要同步去关联远端代码时.如果你本地的代码和远端代码没有冲突时,可以直接通过<code>git pull</code>解决.但是如果可能发生冲突怎么办.直接<code>git pull</code>会拒绝覆盖当前的修改.遇到这种情况,需要先保存本地的代码,进行<code>git pull</code>,然后再pop出本地代码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash<br>git pull<br>git stash list <span class="hljs-comment"># 查看储藏记录列表</span><br>git stash pop<br></code></pre></td></tr></table></figure><p><strong>工作流被打断,需要先做别的需求</strong>：当开发进行到一半,老板过来跟你说"线上有个bug,你现在给我改好,不然扣你鸡腿".当然,你可以开一个新的分支,把当前代码提交过去,回头再merge,具体代码如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>git stash        <span class="hljs-comment">#保存开发到一半的代码</span><br>git checkout master<br>edit emergency fix  <span class="hljs-comment">#一些对主分支的修改</span><br>git commit -a -m <span class="hljs-string">&quot;Fix in a hurry&quot;</span><br>git stash pop   <span class="hljs-comment">#将代码追加到最新的提交之后</span><br></code></pre></td></tr></table></figure><p><strong>提交特定文件</strong>：如果对多个文件做了修改,但是只想提交几个文件,或者想先暂时保存几个修改,测试其他文件的执行结果.可以通过<code>git stash save --keep-index</code>来进行.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ... hack hack hack ...</span><br> git add --patch foo            <span class="hljs-comment">#只将第一部分加入管理the index</span><br> git stash save --keep-index   <span class="hljs-comment">#将其余部分保存起来</span><br> edit/build/test first part<br> git commit -m <span class="hljs-string">&#x27;First part&#x27;</span>    <span class="hljs-comment">#提交全部的git管理中的代码</span><br> git stash pop                 <span class="hljs-comment">#继续进行存储代码的工作</span><br><span class="hljs-comment"># ... repeat above five steps until one commit remains ...</span><br> edit/build/test remaining parts<br> git commit foo -m <span class="hljs-string">&#x27;Remaining parts&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>恢复被错误<code>clear/drop</code>的存储</strong>：如果因为失误对存储仓库进行了<code>clear</code>或者<code>drop</code>操作,在一般机制下是不能恢复的.但是可以通过以下指令来获取仍在仓库中的,但是已经不可获取的存储列表</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">git fsck</span> <span class="hljs-literal">--</span><span class="hljs-comment">unreachable |</span><br><span class="hljs-comment">grep commit | cut</span> <span class="hljs-literal">-</span><span class="hljs-comment">d\</span>  <span class="hljs-literal">-</span><span class="hljs-comment">f3 |</span><br><span class="hljs-comment">xargs git log</span> <span class="hljs-literal">--</span><span class="hljs-comment">merges</span> <span class="hljs-literal">--</span><span class="hljs-comment">no</span><span class="hljs-literal">-</span><span class="hljs-comment">walk</span> <span class="hljs-literal">--</span><span class="hljs-comment">grep=WIP</span><br></code></pre></td></tr></table></figure><h3 id="配置.gitignore文件">14.<code>配置.gitignore</code>文件</h3><p>把要忽略的文件名填进去，Git就会自动忽略这些文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 忽略所有.开头的隐藏文件:</span><br>.*<br><span class="hljs-comment"># 忽略所有.class文件:</span><br>*.class<br><br><span class="hljs-comment"># 排除忽略.gitignore和App.class:</span><br>!.gitignore<br>!App.class<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>项目工程管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更有效的更积极的工作生活</title>
    <link href="/2023/12/18/%E6%9B%B4%E6%9C%89%E6%95%88%E7%9A%84%E6%9B%B4%E7%A7%AF%E6%9E%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%94%9F%E6%B4%BB/"/>
    <url>/2023/12/18/%E6%9B%B4%E6%9C%89%E6%95%88%E7%9A%84%E6%9B%B4%E7%A7%AF%E6%9E%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%94%9F%E6%B4%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="更有效的更积极的工作生活">更有效的更积极的工作生活</h1><p>《孟子.滕文公章句上》中提到”劳心者治人，劳力者治于人；治于人者食人，治人者食于人；天下之通义也。“</p><p><strong>把以下几点当作习惯去执行，能有效的提高自身的水平和工作效率：</strong></p><blockquote><ol type="1"><li>把事情想明白，说清楚，跟别人商量好</li><li>写代码，注意边界条件和编码规范，写单测，基本做到无bug提测</li><li>工作中做好计划和进度跟踪，沟通和汇报，不把问题遗留到变成事故</li><li>思考和分析，如何优化目前的工作流程，引入工具和方法，提升生产效率</li><li>把自己工作中用到的技术用熟，搞清楚原理，优点短处，适用场景</li><li>不断接触新技术思想和工具，完善自身知识体系结构</li><li>深入学习至少一个常用开源项目，源码层面系统掌握这项技术</li><li>持续坚持学习和技术内容输出，每个星期产出2篇原创技术文章</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装paddle-gpu后找不到动态链接库libcuda.so</title>
    <link href="/2023/12/10/%E5%AE%89%E8%A3%85paddle-gpu%E5%90%8E%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93libcuda-so/"/>
    <url>/2023/12/10/%E5%AE%89%E8%A3%85paddle-gpu%E5%90%8E%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93libcuda-so/</url>
    
    <content type="html"><![CDATA[<h1id="安装paddle-gpu后找不到动态链接库libcuda.so">安装<strong>paddle-gpu</strong>后找不到动态链接库libcuda.so</h1><p>按照文档安装<strong>paddle-gpu</strong>后，<strong>paddle-gpu</strong>不能正常运行，并报错。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import paddle</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; paddle.utils.run_check()</span><br>Running verify PaddlePaddle program ...<br>I1209 22:43:10.566331  2436 interpretercore.cc:237] New Executor is Running.<br>W1209 22:43:10.566608  2436 gpu_resources.cc:119] Please NOTE: device: 0, GPU Compute Capability: 8.6, Driver API Version: 12.0, Runtime API Version: 11.8<br>W1209 22:43:10.585208  2436 gpu_resources.cc:149] device: 0, cuDNN Version: 8.6.<br>W1209 22:43:12.852262  2436 dynamic_loader.cc:303] The third-party dynamic library (libcuda.so) that Paddle depends on is not configured correctly. (error code is libcuda.so: cannot open shared object file: No such file or directory)<br>  Suggestions:<br>  1. Check if the third-party dynamic library (e.g. CUDA, CUDNN) is installed correctly and its version is matched with paddlepaddle you installed.<br>  2. Configure third-party dynamic library environment variables as follows:<br>  - Linux: set LD_LIBRARY_PATH by `export LD_LIBRARY_PATH=...`<br>  - Windows: set PATH by `set PATH=XXX;<br><br></code></pre></td></tr></table></figure><ul><li>首先从log 的提示中，可以看出是无法链接到<strong>libcuda.so</strong>文件，先查找<strong>libcuda.so</strong>文件的位置。作为动态链接库一般都安装在<code>/usr/</code>文件夹下。在<code>/usr/</code>文件夹下查找<strong>libcuda.so</strong>文件,其路径为<code>/usr/lib/wsl/lib/libcuda.so</code>。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">user@unutu:sudo find /usr/ -name &quot;libcuda.so&quot;<br>/usr/lib/wsl/lib/libcuda.so<br></code></pre></td></tr></table></figure><p>在这里补充一下，我是在conda的子环境<strong>env_paddle</strong>中安装了paddle-gpu。因此需要将子环境<strong>env_paddle</strong>的库路径<code>～/miniconda3/envs/env_paddle/lib/</code> 在<code>～/.bashrc</code>中加入到环境变量，使用指令<code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:~/miniconda3/envs/env_paddle/lib/</code>。</p><ul><li>然后在环境变量下创建软连接，具体用法是：<code>ln -s  [源文件]  [软链接文件]</code>。这样paddle就能在环境变量下链接到到<strong>libcuda.so</strong>文件。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s  /usr/lib/wsl/lib/libcuda.so  ~/miniconda3/envs/env_paddle/lib/libcuda.so<br></code></pre></td></tr></table></figure><ul><li>在shell中输入<code>python -c "import paddle; paddle.utils.run_check()"</code>，提示<code>PaddlePaddle is installed successfully!</code>。则问题已解决。</li></ul>]]></content>
    
    
    <categories>
      
      <category>日常部署排故</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>paddle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在线标定_前后帧三角测量</title>
    <link href="/2023/12/06/%E5%9C%A8%E7%BA%BF%E6%A0%87%E5%AE%9A-%E5%89%8D%E5%90%8E%E5%B8%A7%E4%B8%89%E8%A7%92%E6%B5%8B%E9%87%8F/"/>
    <url>/2023/12/06/%E5%9C%A8%E7%BA%BF%E6%A0%87%E5%AE%9A-%E5%89%8D%E5%90%8E%E5%B8%A7%E4%B8%89%E8%A7%92%E6%B5%8B%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>sdasadsad</p>]]></content>
    
    
    <categories>
      
      <category>自动驾驶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>在线标定</tag>
      
      <tag>环视相机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo+github+windows搭建个人博客</title>
    <link href="/2023/12/06/hexo-github-windows%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/12/06/hexo-github-windows%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1id="hexogithubwindows搭建个人博客">hexo+github+windows搭建个人博客</h1><p>对于搭载免费的静态网页，gitee是个不错的选择。但由于gitee需要实名备案，最终选择github来搭载个人博客的静态网页。但github上的page只支持public仓库，且支持为一个静态网页I/O，且静态网页仓库名必须命名为<strong><em>用户名</em></strong>.github.io。而且通过page功能发布的网页网址定义为https://<strong><em>用户名</em></strong>.github.io/。</p><h2 id="个人博客的搭建从无到有">个人博客的搭建：从无到有</h2><h3 id="第一步github-page搭建">第一步：GitHub Page搭建</h3><p>1、在Github新建一个仓库，命名为:<strong><em>用户名</em></strong>.github.io</p><p>2、 启用GitHub Page：</p><p>点击“Setting”菜单进入设置</p><p>首先点击”Launch automatic page generator”</p><h3 id="第二步安装hexo">第二步：安装Hexo</h3><ol type="1"><li>安装npm</li><li>安装git</li><li>安装hexo</li></ol><h3 id="第二步使用图床">第二步：使用图床</h3><h5 id="使用github-仓库作为图床">1. 使用github 仓库作为图床</h5><p>总得需要一个放图片和视频等东西的地方，比较小的可以直接放到 GitHub上，但是 repository 目前有 <strong>≤1GB</strong> 的限制。</p><ol type="1"><li>准备一个 Github 账号；</li><li>搭建Github图床仓库，确保仓库为 <code>public</code> ；</li><li>上传图片设置（Github 创建一个 token; 配置 PicGo，依次打开 图床设置-&gt; Github 图床;）</li><li>加速访问（PicGo设置使用 <ahref="https://link.zhihu.com/?target=https%3A//www.jsdelivr.com/">jsDelivr</a>进行免费加速）；</li><li>typora测试自动上传图床</li></ol><h5 id="使用其他图床">2.使用其他图床</h5><p>除开用 Github 搭建的方式之后，我们也可以用 Gitee进行搭建，搭建方式和本文大致相同。此外，我也推荐几个免费的图床给大家，大家可以根据自己的喜好进行选择；</p><ol type="1"><li><ahref="https://link.zhihu.com/?target=https%3A//imgchr.com/">路过图床</a></li><li><ahref="https://link.zhihu.com/?target=https%3A//sm.ms/">SM.MS</a></li><li><ahref="https://link.zhihu.com/?target=https%3A//imgur.com/">Imgur</a></li></ol><h3 id="第三步安装fluid主题示例">第三步：安装fluid主题示例</h3><p>Fluid 是基于 Hexo 的一款 Material Design 风格的主题，由 <ahref="https://github.com/fluid-dev">Fluid-dev (opens newwindow)</a>负责开发与维护。用户手册见<ahref="https://fluid-dev.github.io/hexo-fluid-docs/start/">开始使用 |Hexo Fluid 用户手册 (fluid-dev.github.io)</a></p><p>安装教程见:<ahref="https://fluid-dev.github.io/hexo-fluid-docs/start/#安装主题">开始使用| Hexo Fluid 用户手册 (fluid-dev.github.io)</a></p><h3 id="第四步配置本地公式">第四步：配置本地公式</h3><p>hexo默认使用 Markdown渲染器渲染latex数学公式，对于一些大型矩阵的复杂公式的并不支持，因此需要更换渲染器（mathjax可选择性更换）。需要安配置不同的<code>engine</code>，（比如mathjax或者katex）。并对<code>主题配置</code>进行修改。</p><blockquote><p>"站点配置" 指的 Hexo 博客目录下的 _config.yml，"主题配置" 指的是theme/fluid/_config.yml 或者 <em>config.fluid.yml，注意区分（实际操作时，建议修改</em>_config.fluid.yml ）；</p></blockquote><p><strong>设置主题配置</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">math:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br></code></pre></td></tr></table></figure><blockquote><p><code>specific</code>: 建议开启。当为 true 时，只有在文章 <ahref="https://hexo.io/zh-cn/docs/front-matter">front-matter (opens newwindow)</a>里指定(如果使用mathjax渲染器)<code>mathjax: true</code>才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度。</p></blockquote><p><strong>更换 Markdown 渲染器</strong></p><p>由于 Hexo 默认的 Markdown渲染器不支持复杂公式，所以需要更换渲染器（mathjax 可选择性更换）。</p><p>然后根据上方配置不同的 <code>engine</code>，推荐更换如下渲染器：</p><blockquote><p>mathjax</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm uninstall hexo-renderer-marked --save <span class="hljs-comment"># 先将原有的渲染器卸载</span><br>npm install hexo-renderer-pandoc --save   <span class="hljs-comment"># 安装pandoc</span><br></code></pre></td></tr></table></figure><p><strong>并且还需<ahref="https://github.com/jgm/pandoc/blob/master/INSTALL.md">安装Pandoc</a></strong>，安装完后，记得电脑重启一下。</p></blockquote><h3 id="section"></h3><h2id="本地端个人博客在不同设备端的同步与迁移">本地端个人博客在不同设备端的同步与迁移</h2><p>上一节中，在本地创建了hexo项目的目录。其目录结构如下</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/image-20240104095217144.png"alt="image-20240104095217144" /><figcaption aria-hidden="true">image-20240104095217144</figcaption></figure><p>在目录下使用<code>git status</code>，提示<code>fatal: Not a git repository (or any of the parent directories): .git</code>。显然，hexo项目不是以git仓库的形式与github.io保持同步的。</p><p>因此，当前项目跟一个远程仓库关联起来，好管理环境文件。为了保证文件安全，建立一个hexo分支与main分支区别。把hexo分支pull到本地进行修改，每次修改完本地仓库后，再push到hexo分支，再将两个分支merge。但是repository 目前有 <strong>≤1GB</strong>的限制,branch会占用容量。所以也可以新建额外的仓库用来同步。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/BIGBIGBrotherAI/BlogImg@main/4906139-652af9cbae0a1a3d.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="参考">参考</h2><p>1.<ahref="https://kaiboshi.gitee.io/posts/ccdb282h.html#:~:text=1%20直接在Hexo根目录执行%20gulp%20或者%20gulp%20default%20，这个命令相当于%20hexo,2%20在Hexo根目录执行%20gulp%20build%20，这个命令与第1种相比是：在最后又加了个%20hexo%20d%20，等于说生成、压缩文件后又帮你自动部署了。">Hexo博客主题安装和优化（五）优化图片，代码| Kaiboshiの博客 (gitee.io)</a></p><p>2.<ahref="https://tangh.github.io/articles/hexo-with-github-pages-static-site/">Hexo+ GitHub Pages 静态网站 - 雨天等放晴 (tangh.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bash大法好</title>
    <link href="/2023/12/04/Bash%E5%A4%A7%E6%B3%95%E5%A5%BD/"/>
    <url>/2023/12/04/Bash%E5%A4%A7%E6%B3%95%E5%A5%BD/</url>
    
    <content type="html"><![CDATA[<p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell既是一种命令语言，又是一种程序设计语言。</p><ol type="1"><li><h2 id="ffmpeg-处理视频文件的一些操作">ffmpeg处理视频文件的一些操作</h2></li></ol><p>在172.16.2.88服务器上，/data01/ffmpeg-n5.1-latest-linux64-lgpl-shared-5.1.tar.gz是一个比较新的ffmpeg版本，该版本可以使用n卡做编解码器，也就是是-chevc_nvenc参数加速处理。</p><p>该版本包含：(decoders: hevc hevc_qsv hevc_cuvid ) (encoders: hevc_amfhevc_nvenc hevc_qsv hevc_vaapi libkvazaar)，hevc_amf是amd集成显卡的编码器，hevc_qsv是intel集成显卡的编码器。</p><ol type="1"><li><h3 id="常用参数来自网络">常用参数（来自网络）</h3></li></ol><table><thead><tr class="header"><th>基本选项:</th><th></th></tr></thead><tbody><tr class="odd"><td>-formats</td><td>输出所有可用格式</td></tr><tr class="even"><td>-f fmt</td><td>指定格式(音频或视频格式)</td></tr><tr class="odd"><td>-i filename</td><td>指定输入文件名，在linux下当然也能指定:0.0(屏幕录制)或摄像头</td></tr><tr class="even"><td>-y</td><td>覆盖已有文件</td></tr><tr class="odd"><td>-t duration</td><td>记录时长为t</td></tr><tr class="even"><td>-fs limit_size</td><td>设置文件大小上限</td></tr><tr class="odd"><td>-ss time_off</td><td>从指定的时间(s)开始， [-]hh:mm:ss[.xxx]的格式也支持</td></tr><tr class="even"><td>-itsoffset time_off</td><td>设置时间偏移(s)，该选项影响所有后面的输入文件。该偏移被加到输入文件的时戳，定义一个正偏移意味着相应的流被延迟了offset秒。 [-]hh:mm:ss[.xxx]的格式也支持</td></tr><tr class="odd"><td>-title string</td><td>标题</td></tr><tr class="even"><td>-timestamp time</td><td>时间戳</td></tr><tr class="odd"><td>-author string</td><td>作者</td></tr><tr class="even"><td>-copyright string</td><td>版权信息</td></tr><tr class="odd"><td>-comment string</td><td>评论</td></tr><tr class="even"><td>-album string</td><td>album名</td></tr><tr class="odd"><td>-v verbose</td><td>与log相关的</td></tr><tr class="even"><td>-target type</td><td>设置目标文件类型("vcd", "svcd", "dvd", "dv", "dv50", "pal-vcd","ntsc-svcd", ...)</td></tr><tr class="odd"><td>-dframes number</td><td>设置要记录的帧数</td></tr></tbody></table><table><thead><tr class="header"><th>视频选项:</th><th></th></tr></thead><tbody><tr class="odd"><td>-b</td><td>指定比特率(bits/s)，似乎ffmpeg是自动VBR的，指定了就大概是平均比特率</td></tr><tr class="even"><td>-bitexact</td><td>使用标准比特率</td></tr><tr class="odd"><td>-vb</td><td>指定视频比特率(bits/s)</td></tr><tr class="even"><td>-vframes number</td><td>设置转换多少帧(frame)的视频</td></tr><tr class="odd"><td>-r rate</td><td>帧速率(fps)（可以改，确认非标准桢率会导致音画不同步，所以只能设定为15或者29.97）</td></tr><tr class="even"><td>-s size</td><td>指定分辨率 (320x240)</td></tr><tr class="odd"><td>-aspect aspect</td><td>设置视频长宽比(4:3, 16:9 or 1.3333, 1.7777)</td></tr><tr class="even"><td>-croptop size</td><td>设置顶部切除尺寸(in pixels)</td></tr><tr class="odd"><td>-cropbottom size</td><td>设置底部切除尺寸(in pixels)</td></tr><tr class="even"><td>-cropleft size</td><td>设置左切除尺寸 (in pixels)</td></tr><tr class="odd"><td>-cropright size</td><td>设置右切除尺寸 (in pixels)</td></tr><tr class="even"><td>-padtop size</td><td>设置顶部补齐尺寸(in pixels)</td></tr><tr class="odd"><td>-padbottom size</td><td>底补齐(in pixels)</td></tr><tr class="even"><td>-padleft size</td><td>左补齐(in pixels)</td></tr><tr class="odd"><td>-padright size</td><td>右补齐(in pixels)</td></tr><tr class="even"><td>-padcolor color</td><td>补齐带颜色(000000-FFFFFF)</td></tr><tr class="odd"><td>-vn</td><td>取消视频</td></tr><tr class="even"><td>-vcodec codec</td><td>强制使用codec编解码方式('copy' to copy stream)</td></tr><tr class="odd"><td>-sameq</td><td>使用同样视频质量作为源（VBR）</td></tr><tr class="even"><td>-pass n</td><td>选择处理遍数（1或者2）。两遍编码非常有用。第一遍生成统计信息，第二遍生成精确的请求的码率</td></tr><tr class="odd"><td>-passlogfile file</td><td>选择两遍的纪录文件名为file</td></tr><tr class="even"><td>-newvideo</td><td>在现在的视频流后面加入新的视频流</td></tr><tr class="odd"><td>-vsync</td><td>The -vsync option has the following values:-1: auto (default) 0:passthrough 1: cfr (constant frame rate) 2: vfr (variable framerate)</td></tr><tr class="even"><td>-fps_mode</td><td>The -vsync option has the following values:-1: auto (default) 0:passthrough 1: cfr (constant frame rate) 2: vfr (variable framerate)</td></tr></tbody></table><table><thead><tr class="header"><th>高级视频选项</th><th></th></tr></thead><tbody><tr class="odd"><td>-pix_fmt format</td><td>set pixel format, 'list' as argument shows all the pixel formatssupported</td></tr><tr class="even"><td>-intra</td><td>仅适用帧内编码</td></tr><tr class="odd"><td>-qscale q</td><td>以<数值>质量为基础的VBR，取值0.01-255，约小质量越好</td></tr><tr class="even"><td>-loop_input</td><td>设置输入流的循环数(目前只对图像有效)</td></tr><tr class="odd"><td>-loop_output</td><td>设置输出视频的循环数，比如输出gif时设为0表示无限循环</td></tr><tr class="even"><td>-g int</td><td>设置图像组大小</td></tr><tr class="odd"><td>-cutoff int</td><td>设置截止频率</td></tr><tr class="even"><td>-qmin int</td><td>设定最小质量，与-qmax（设定最大质量）共用，比如-qmin 10 -qmax31</td></tr><tr class="odd"><td>-qmax int</td><td>设定最大质量</td></tr><tr class="even"><td>-qdiff int</td><td>量化标度间最大偏差 (VBR)</td></tr><tr class="odd"><td>-bf int</td><td>使用frames B 帧，支持mpeg1,mpeg2,mpeg4</td></tr></tbody></table><ol type="1"><li><h3id="切割视频可用于从四合一视频中快速分割出单视角视频">切割视频——可用于从四合一视频中快速分割出单视角视频</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg -i <span class="hljs-variable">$&#123;video_name&#125;</span>.mp4 -c hevc_nvenc -vf crop=1280:1280:0:2 -r 5 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_le.mp4<br></code></pre></td></tr></table></figure><ol type="1"><li><h3id="视频拼接可用于快速将单视角视频拼为41的视频">视频拼接——可用于快速将单视角视频拼为4*1的视频</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_fr.mp4 -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_le.mp4 -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_re.mp4 -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_ri.mp4 -filter_complex vstack=inputs=4 -c hevc_nvenc -b:v 3000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_4x1.mp4<br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="视频旋转">视频旋转</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg -i input.mp4 -c copy -metadata:s:v:0 rotate=90 output.mp4<br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="视频抽帧画质好">视频抽帧（画质好）</h3></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs COBOL">ffmpeg -i /data/video_1.mp4 -f image2  -vf fps=fps=1/60 -qscale:v 2 /data/mp4-%05d.jpeg<br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="视频抽帧画质差">视频抽帧（画质差）</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg -i inputfile.avi -r 1 -f image2 image-%05d.jpeg<br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="批量视频抽帧">批量视频抽帧</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-meta">#!/usr/bin/env bash</span><br> <br>videos_root=/data/videos<br>save_root=/data/video_imgs/Image_fps50/<br><span class="hljs-keyword">for</span> video <span class="hljs-keyword">in</span> <span class="hljs-variable">$videos_root</span>/*;<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$video</span><br>save_dir=$save_root$(<span class="hljs-built_in">basename</span> <span class="hljs-variable">$video</span> .avi)<br><span class="hljs-keyword">if</span> [ ! -d <span class="hljs-variable">$save_dir</span> ];<span class="hljs-keyword">then</span><br><span class="hljs-built_in">mkdir</span> <span class="hljs-variable">$save_dir</span><br><span class="hljs-keyword">fi</span><br>ffmpeg -i <span class="hljs-variable">$video</span> -f image2  -vf fps=fps=50 -qscale:v 2 <span class="hljs-variable">$save_dir</span>/mp4-%05d.jpeg<br> <br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="组合前面几个命令2-2视频转4-1视频">组合前面几个命令——2 *2视频转4 * 1视频</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Bash">video_name=<span class="hljs-variable">$1</span><br><span class="hljs-built_in">mkdir</span> results<br>ffmpeg -y -i <span class="hljs-variable">$&#123;video_name&#125;</span>.mp4 -c hevc_nvenc -vf crop=1920:1280:0:0 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_ri.mp4<br>ffmpeg -y -i <span class="hljs-variable">$&#123;video_name&#125;</span>.mp4 -c hevc_nvenc -vf crop=1920:1280:1920:0 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_le.mp4<br>ffmpeg -y -i <span class="hljs-variable">$&#123;video_name&#125;</span>.mp4 -c hevc_nvenc -vf crop=1920:1280:0:1280 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_fr.mp4<br>ffmpeg -y -i <span class="hljs-variable">$&#123;video_name&#125;</span>.mp4 -c hevc_nvenc -vf crop=1920:1280:1920:1280 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_re.mp4<br>ffmpeg -y -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_fr.mp4 -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_le.mp4 -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_re.mp4 -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_ri.mp4 -filter_complex vstack=inputs=4 -c hevc_nvenc -b:v 40000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_4x1.mp4<br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="按时间截取视频某一段">按时间截取视频某一段</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg  -i videodump_2023_02_21_15_49_26.mp4 -vcodec copy -acodec copy -ss 00:00:05 -to 00:00:25 ./out1.mp4 -y<br></code></pre></td></tr></table></figure><ol type="1"><li><h3id="四张单视角图片合并为一张4x1的图片">四张单视角图片合并为一张4x1的图片</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg -i front.png -i left.png -i rear.png -i right.png -filter_complex vstack=inputs=4 img1.png<br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="到41多个视频合并">2×2到4×1；多个视频合并</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment">##############################################################################################</span><br>视频信息：地址、后缀名、前后左右顺序、分辨率<br>root=/home/calmcar/wly/Hozon_ep40/54_white<br>suffix=.mp4<br>direct1=fr <span class="hljs-comment"># 左上</span><br>direct2=re <span class="hljs-comment"># 右上</span><br>direct3=le <span class="hljs-comment"># 左下</span><br>direct4=ri <span class="hljs-comment"># 右下</span><br>w=1280<br>h=960<br><span class="hljs-comment">##############################################################################################</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$&#123;root&#125;</span><br><span class="hljs-built_in">rm</span> videos.txt<br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> *<span class="hljs-variable">$&#123;suffix&#125;</span>;<span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;file &quot;</span><span class="hljs-variable">$&#123;name&#125;</span><span class="hljs-string">&quot;&quot;</span>&gt;&gt;videos.txt;<span class="hljs-keyword">done</span><br>ffmpeg -f concat -safe 0 -i videos.txt -c copy concat<span class="hljs-variable">$&#123;suffix&#125;</span><br><span class="hljs-comment">##############################################################################################</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3id="要在ffmpeg中使用多个显卡进行视频处理你可以使用ffmpeg的-hwaccel选项和-cv选项">要在FFmpeg中使用多个显卡进行视频处理，你可以使用FFmpeg的<code>-hwaccel</code>选项和<code>-c:v</code>选项。</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ffmpeg -hwaccel_device 0,1 -hwaccel cuda -i input.mp4 -c:v h264_nvenc -gpu 0,1 output.mp4<br></code></pre></td></tr></table></figure><p>案例：2x2--&gt;4x1；多个视频合并成一个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 视频信息：地址、后缀名、前后左右顺序、分辨率</span><br>root=/home/calmcar/wly/Hozon_ep40/54_white <span class="hljs-comment"># 多个视频存放的目录</span><br>suffix=.mp4 <span class="hljs-comment"># 后缀</span><br>direct1=fr <span class="hljs-comment"># 左上</span><br>direct2=re <span class="hljs-comment"># 右上</span><br>direct3=le <span class="hljs-comment"># 左下</span><br>direct4=ri <span class="hljs-comment"># 右下</span><br>w=1280<br>h=960<br><span class="hljs-comment"># 合并视频</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$&#123;root&#125;</span><br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> *<span class="hljs-variable">$&#123;suffix&#125;</span>;<span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;file &quot;</span><span class="hljs-variable">$&#123;name&#125;</span><span class="hljs-string">&quot;&quot;</span> &gt;&gt; videos.txt;<span class="hljs-keyword">done</span><br>ffmpeg -f concat -safe 0 -i videos.txt -c copy concat<span class="hljs-variable">$&#123;suffix&#125;</span><br><span class="hljs-comment"># 2x2--&gt;4x1</span><br><span class="hljs-built_in">mkdir</span> results<br>video_name=concat<br>ffmpeg -i <span class="hljs-variable">$&#123;video_name&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span> -vf crop=<span class="hljs-variable">$w</span>:<span class="hljs-variable">$h</span>:0:0 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_<span class="hljs-variable">$&#123;direct1&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span><br>ffmpeg -i <span class="hljs-variable">$&#123;video_name&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span> -vf crop=<span class="hljs-variable">$w</span>:<span class="hljs-variable">$h</span>:<span class="hljs-variable">$w</span>:0 -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_<span class="hljs-variable">$&#123;direct2&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span><br>ffmpeg -i <span class="hljs-variable">$&#123;video_name&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span> -vf crop=<span class="hljs-variable">$w</span>:<span class="hljs-variable">$h</span>:0:<span class="hljs-variable">$h</span> -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_<span class="hljs-variable">$&#123;direct3&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span><br>ffmpeg -i <span class="hljs-variable">$&#123;video_name&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span> -vf crop=<span class="hljs-variable">$w</span>:<span class="hljs-variable">$h</span>:<span class="hljs-variable">$w</span>:<span class="hljs-variable">$h</span> -b:v 10000k results/<span class="hljs-variable">$&#123;video_name&#125;</span>_<span class="hljs-variable">$&#123;direct4&#125;</span><span class="hljs-variable">$&#123;suffix&#125;</span><br>ffmpeg -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_fr<span class="hljs-variable">$&#123;suffix&#125;</span> -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_le<span class="hljs-variable">$&#123;suffix&#125;</span> -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_re<span class="hljs-variable">$&#123;suffix&#125;</span> -i results/<span class="hljs-variable">$&#123;video_name&#125;</span>_ri<span class="hljs-variable">$&#123;suffix&#125;</span> -filter_complex vstack=inputs=4 -b:v 3000k <span class="hljs-variable">$&#123;video_name&#125;</span>4<span class="hljs-variable">$&#123;suffix&#125;</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h2 id="图片筛选时的一些便捷操作">图片筛选时的一些便捷操作</h2></li><li><h3id="当我们有一堆单视角图片以前视角为准删除了相似帧图片后希望将保留下来的同帧号左右后视角图片取出时可以这么干">当我们有一堆单视角图片，以前视角为准删除了相似帧图片后，希望将保留下来的同帧号左右后视角图片取出时，可以这么干</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 首先新建四个文件夹，用于保存各视角图片</span><br><span class="hljs-built_in">mkdir</span> fr<br><span class="hljs-built_in">mkdir</span> le<br><span class="hljs-built_in">mkdir</span> re<br><span class="hljs-built_in">mkdir</span> ri<br><span class="hljs-comment"># 首先通过文件名，将四个视角的图片分别保存至四视角文件夹</span><br><span class="hljs-built_in">mv</span> *_fr_* ./fr<br><span class="hljs-built_in">mv</span> *_le_* ./le<br><span class="hljs-built_in">mv</span> *_re_* ./re<br><span class="hljs-built_in">mv</span> *_ri_* ./ri<br><span class="hljs-comment"># 之后我们以前视角作为基准，找出其他文件夹中包含同视频编号、md5值和帧号的图片</span><br><span class="hljs-built_in">cd</span> fr <br><span class="hljs-built_in">ls</span> * &gt; ../fr.txt<br><span class="hljs-built_in">cd</span> ..<br><span class="hljs-comment"># 此时我们主目录中除保存四视角图片文件夹外，还有一个fr.txt中保存有所有前视角图片名</span><br><span class="hljs-comment"># 之后我们要对fr.txt做一些操作</span><br>vim fr.txt<br><span class="hljs-comment"># 在vim界面中输入</span><br>:%s/_fr_/_le_/g <span class="hljs-comment"># 这个命令表示将所有_fr_替换为_le_</span><br>:x <span class="hljs-comment"># 保存退出</span><br><span class="hljs-comment"># 之后在终端输入</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `<span class="hljs-built_in">cat</span> fr.txt`;<span class="hljs-keyword">do</span> <span class="hljs-built_in">mv</span> le/<span class="hljs-variable">$&#123;i&#125;</span> ./;<span class="hljs-keyword">done</span>;<br><span class="hljs-comment"># 这样操作就可以把左视角与前视角文件夹的交集图片取出</span><br><span class="hljs-comment"># 同样对右、后文件夹操作</span><br>vim fr.txt<br><span class="hljs-comment"># 在vim界面中输入</span><br>:%s/_le_/_re_/g <span class="hljs-comment"># 这个命令表示将所有_fr_替换为_le_</span><br>:x <span class="hljs-comment"># 保存退出</span><br><span class="hljs-comment"># 之后在终端输入</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `<span class="hljs-built_in">cat</span> fr.txt`;<span class="hljs-keyword">do</span> <span class="hljs-built_in">mv</span> re/<span class="hljs-variable">$&#123;i&#125;</span> ./;<span class="hljs-keyword">done</span>;<br>vim fr.txt<br><span class="hljs-comment"># 在vim界面中输入</span><br>:%s/_re_/_ri_/g <span class="hljs-comment"># 这个命令表示将所有_fr_替换为_le_</span><br>:x <span class="hljs-comment"># 保存退出</span><br><span class="hljs-comment"># 之后在终端输入</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `<span class="hljs-built_in">cat</span> fr.txt`;<span class="hljs-keyword">do</span> <span class="hljs-built_in">mv</span> ri/<span class="hljs-variable">$&#123;i&#125;</span> ./;<span class="hljs-keyword">done</span>;<br><span class="hljs-comment"># 最后将前视角文件夹中图片取出，删除四文件夹和fr.txt即可</span><br><span class="hljs-built_in">mv</span> ./fr/* ./<br><span class="hljs-built_in">rm</span> -r fr/ re/ ri/ le/ fr.txt<br></code></pre></td></tr></table></figure><ol type="1"><li><h3id="遍历文件夹中所有文件不带后缀">遍历文件夹中所有文件（不带后缀）</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">basename</span> --suffix=.png -- *.png<br></code></pre></td></tr></table></figure><ol type="1"><li><h2 id="git-操作">Git 操作</h2></li><li><h3 id="git-强制回退删除已提交慎用">git强制回退，删除已提交（<strong><em>慎用</em></strong>）</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git reset --hard commit_id<br>git push --force origin 3dod<br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git-本地仓库关联远程仓库">git 本地仓库关联远程仓库</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git remote <span class="hljs-comment"># 查看当前有哪些远程仓库</span><br>git remote -v <span class="hljs-comment"># 列出当前仓库中已配置的远程仓库，并显示它们的 URL</span><br>git remote add &lt;本地仓库名&gt; &lt;远程仓库url&gt;  <span class="hljs-comment"># 本地仓库关联远程仓库</span><br>git remote <span class="hljs-built_in">rm</span>  &lt;远程仓库别名&gt;  <span class="hljs-comment"># 删除远程仓库</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git分支操作">Git分支操作</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git branch                  <span class="hljs-comment"># 查看分支</span><br>git branch  (branchname)     <span class="hljs-comment"># 创建新分支(branchname) </span><br>git checkout -b (branchname) <span class="hljs-comment"># 创建新分支并(branchname) 立即切换到该分支</span><br>git checkout (branchname)   <span class="hljs-comment"># 可以切换到分支(branchname) </span><br>git branch -d (branchname)  <span class="hljs-comment"># 可以删除分支(branchname) </span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git-本地仓库添加暂存文件">Git 本地仓库添加暂存文件</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git add &lt;文件1&gt; &lt;文件1&gt; &lt;文件2&gt; &lt;文件3&gt; ...<br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git-命令来查看相关文件的状态查看更新的详细信息">Git命令来查看相关文件的状态/查看更新的详细信息</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git status   <span class="hljs-comment"># 查看相关文件的状态</span><br>git diff     <span class="hljs-comment"># 查看尚未缓存的改动更新的详细信息</span><br>git diff --cached  <span class="hljs-comment"># 查看已缓存的改动： </span><br>git diff HEAD      <span class="hljs-comment"># 查看已缓存的与未缓存的所有改动：</span><br>git diff --<span class="hljs-built_in">stat</span>    <span class="hljs-comment"># 显示摘要而非整个 diff</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git-取消已缓存的内容">Git 取消已缓存的内容</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git reset HEAD test.txt   <span class="hljs-comment"># 用于取消已缓存的内容，如我们要取消已提交的test.txt文件.执行完之后，再使用commit提交时，test.txt文件不会被提交。</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git-提交暂存文件">Git 提交暂存文件</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git commit -m <span class="hljs-string">&quot;&lt;提交说明&gt;&quot;</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git-提交修改到远程仓库">Git 提交修改到远程仓库</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git push &lt;本地仓库名&gt; &lt;远程分支名&gt;<br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git-拉取远程仓库">git 拉取远程仓库</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git pull  <span class="hljs-comment">#相当于是从远程获取最新版本并merge到本地</span><br>git fetch  <span class="hljs-comment"># 相当于是从远程获取最新版本到本地，不会自动合并。</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git合并操作">Git合并操作</h3></li></ol><p>合并的时候，最大的难点就是冲突了，合并并不仅仅是简单的文件添加、移除的操作，Git也会合并修改，如果我们在两个分支中同时修改了同一个文件，这时再合并，就可能会产生冲突，冲突并不可怕，可怕的是要怎样去解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git merge branchname <span class="hljs-comment">#将任意分支合并到到当前分支中</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git查看提交历史">Git查看提交历史</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git <span class="hljs-built_in">log</span> <span class="hljs-comment"># 命令查看</span><br>git –oneline <span class="hljs-comment"># 查看历史记录的简洁版本</span><br>git –graph <span class="hljs-comment"># 查看历史中什么时候出现了分支、合并</span><br>git –reverse <span class="hljs-comment"># 逆向显示所有日志</span><br>git –author <span class="hljs-comment"># 查找指定用户的提交日志</span><br>git –since、–before、 --<span class="hljs-keyword">until</span>、–after <span class="hljs-comment"># 指定筛选日期</span><br>git –no-merges <span class="hljs-comment"># 选项以隐藏合并提交</span><br>git <span class="hljs-built_in">log</span> --autho <span class="hljs-comment"># 查找指定用户的提交日志</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="git-标签操作">Git 标签操作</h3></li></ol><p>使用标签可以很方便的永远的记住那个特别的提交快照，比如：我们发一个新的版本时，可以给它加一个“vx.x”版本，这样你可以使用gittag给它打上标签。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git tag -a v1.0 <span class="hljs-comment"># 创建一个带注解的标签,可以很方便的永远的记住那个特别的提交快照</span><br>git tag <span class="hljs-comment"># 查看标签</span><br>git tag -a &lt;tagname&gt; -m <span class="hljs-string">&quot;某某标签&quot;</span> <span class="hljs-comment">#指定标签信息</span><br>git tag -a v1.0 d6f7147 <span class="hljs-comment"># d6f7147提交已发布，可对其追加标签 </span><br>git checkout tag_name <span class="hljs-comment"># 但是，这时候 git 可能会提示你当前处于一个“detached HEAD&quot; 状态。因为 tag 相当于是一个快照，是不能更改它的代码的。如果要在 tag 代码的基础上做修改，你需要一个分支： git checkout -b branch_name tag_name</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3id="配置.gitignore文件"><code>配置.gitignore</code>文件</h3></li></ol><p>把要忽略的文件名填进去，Git就会自动忽略这些文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 忽略所有.开头的隐藏文件:</span><br>.*<br><span class="hljs-comment"># 忽略所有.class文件:</span><br>*.class<br><br><span class="hljs-comment"># 排除忽略.gitignore和App.class:</span><br>!.gitignore<br>!App.class<br></code></pre></td></tr></table></figure><ol type="1"><li><h2 id="一些有用的小工具">一些有用的小工具</h2></li><li><h3 id="pigz多线程压缩">pigz多线程压缩</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-get install -y pigz<br>tar cv filename | pigz -9 -p16 -k &gt; filename.tar.gz<br><span class="hljs-comment"># -9 为压缩级别 -p16为调用线程数量 -k为保留源文件</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="多线程apt-fast">多线程apt-fast</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-add-repository ppa:apt-fast/stable<br>sudo apt-get install apt-fast<br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="conda环境迁移">conda环境迁移</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">conda install conda-pack conda-pack<br>conda pack -p /path/to/env -o env_name.tar.gz<br>tar zxcf env_name.tar.gz -C env_name<br><span class="hljs-built_in">source</span> env_name/bin/activate<br>conda un<br></code></pre></td></tr></table></figure><ol type="1"><li><h2 id="shell网络命令">shell网络命令</h2></li><li><h3id="ssh进行远程登录和执行命令">ssh进行远程登录和执行命令</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ssh user@host  <span class="hljs-comment"># user是要登录的用户名，host是要登录的主机名或IP地址</span><br>ssh -L 8080:localhost:80 user@example.com <span class="hljs-comment"># 创建一个SSH隧道，将本地端口8080转发到远程主机http://example.com的80端口</span><br></code></pre></td></tr></table></figure><ol type="1"><li><h3 id="使用scp进行文件传输">使用scp进行文件传输</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">scp root@192.168.0.101:/var/www/test.txt /var/www/local_dir（本地目录） <span class="hljs-comment"># scp root@192.168.0.101:/var/www/test.txt 把192.168.0.101上的/var/www/test.txt 的文件下载到/var/www/local_dir（本地目录）</span><br>scp -r root@192.168.0.101:/var/www/test（远程目录）   /var/www/（本地目录）<br>scp example.txt user@example.com:/home/user <span class="hljs-comment"># 将本地文件example.txt传输到远程主机http://example.com的/home/user目录下</span><br>scp -r <span class="hljs-built_in">test</span> （本地目录） root@192.168.0.101:/var/www/（远程目录） <span class="hljs-comment"># 把当前目录下的test目录上传到服务器的/var/www/ 目录</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>ffmpeg</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
